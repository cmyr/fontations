// THIS FILE IS AUTOGENERATED.
// Any changes to this file will be overwritten.
// For more information about how codegen works, see font-codegen/README.md

#[allow(unused_imports)]
use crate::codegen_prelude::*;

pub use read_fonts::tables::math::GlyphPartFlags;

/// The [Mathematical Typesetting](https://learn.microsoft.com/en-us/typography/opentype/spec/math) table
#[derive(Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Math {
    /// Offset to MathConstants table, from beginning of MATH table
    pub math_constants: OffsetMarker<MathConstants>,
    /// Offset to MathGlyphInfo table, from beginning of MATH table
    pub math_glyph_info: OffsetMarker<MathGlyphInfo>,
    /// Offset to MathVariants table, from beginning of MATH table
    pub math_variants: OffsetMarker<MathVariants>,
}

impl Math {
    /// Construct a new `Math`
    pub fn new(
        math_constants: MathConstants,
        math_glyph_info: MathGlyphInfo,
        math_variants: MathVariants,
    ) -> Self {
        Self {
            math_constants: math_constants.into(),
            math_glyph_info: math_glyph_info.into(),
            math_variants: math_variants.into(),
        }
    }
}

impl FontWrite for Math {
    #[allow(clippy::unnecessary_cast)]
    fn write_into(&self, writer: &mut TableWriter) {
        (1 as u16).write_into(writer);
        (0 as u16).write_into(writer);
        self.math_constants.write_into(writer);
        self.math_glyph_info.write_into(writer);
        self.math_variants.write_into(writer);
    }
    fn table_type(&self) -> TableType {
        TableType::TopLevel(Math::TAG)
    }
}

impl Validate for Math {
    fn validate_impl(&self, ctx: &mut ValidationCtx) {
        ctx.in_table("Math", |ctx| {
            ctx.in_field("math_constants", |ctx| {
                self.math_constants.validate_impl(ctx);
            });
            ctx.in_field("math_glyph_info", |ctx| {
                self.math_glyph_info.validate_impl(ctx);
            });
            ctx.in_field("math_variants", |ctx| {
                self.math_variants.validate_impl(ctx);
            });
        })
    }
}

impl TopLevelTable for Math {
    const TAG: Tag = Tag::new(b"MATH");
}

impl<'a> FromObjRef<read_fonts::tables::math::Math<'a>> for Math {
    fn from_obj_ref(obj: &read_fonts::tables::math::Math<'a>, _: FontData) -> Self {
        Math {
            math_constants: obj.math_constants().to_owned_table(),
            math_glyph_info: obj.math_glyph_info().to_owned_table(),
            math_variants: obj.math_variants().to_owned_table(),
        }
    }
}

#[allow(clippy::needless_lifetimes)]
impl<'a> FromTableRef<read_fonts::tables::math::Math<'a>> for Math {}

impl<'a> FontRead<'a> for Math {
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        <read_fonts::tables::math::Math as FontRead>::read(data).map(|x| x.to_owned_table())
    }
}

/// [Math Constants](https://learn.microsoft.com/en-gb/typography/opentype/spec/math#mathconstants-table)
#[derive(Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct MathConstants {
    /// Percentage of scaling down for level 1 superscripts and subscripts
    pub script_percent_scale_down: i16,
    /// Percentage of scaling down for level 2 (scriptScript) superscripts and subscripts
    pub script_script_percent_scale_down: i16,
    /// Minimum height required for a delimited expression (contained within parentheses, etc.) to be treated as a sub-formula
    pub delimited_sub_formula_min_height: UfWord,
    /// Minimum height of n-ary operators (such as integral and summation) for formulas in display mode
    pub display_operator_min_height: UfWord,
    /// White space to be left between math formulas to ensure proper line spacing
    pub math_leading: MathValueRecord,
    /// Axis height of the font
    pub axis_height: MathValueRecord,
    /// Maximum height of accent base that does not require raising the accents
    pub accent_base_height: MathValueRecord,
    /// Maximum (ink) height of accent base that does not require flattening the accent
    pub flattened_accent_base_height: MathValueRecord,
    /// The standard shift down applied to subscript elements
    pub subscript_shift_down: MathValueRecord,
    /// Maximum allowed height of the (ink) top of subscripts that does not require moving subscripts further down
    pub subscript_top_max: MathValueRecord,
    /// Minimum allowed drop of the baseline of subscripts relative to the (ink) bottom of the base
    pub subscript_baseline_drop_min: MathValueRecord,
    /// Standard shift up applied to superscript elements
    pub superscript_shift_up: MathValueRecord,
    /// Standard shift of superscripts relative to the base, in cramped style
    pub superscript_shift_up_cramped: MathValueRecord,
    /// Minimum allowed height of the (ink) bottom of superscripts that does not require moving subscripts further up
    pub superscript_bottom_min: MathValueRecord,
    /// Maximum allowed drop of the baseline of superscripts relative to the (ink) top of the base
    pub superscript_baseline_drop_max: MathValueRecord,
    /// Minimum gap between the superscript and subscript ink
    pub sub_superscript_gap_min: MathValueRecord,
    /// The maximum level to which the (ink) bottom of superscript can be pushed to increase the gap between superscript and subscript, before subscript starts being moved down
    pub superscript_bottom_max_with_subscript: MathValueRecord,
    /// Extra white space to be added after each subscript and superscript that occurs after a baseline element, and before each subscript and superscript that occurs before a baseline element
    pub space_after_script: MathValueRecord,
    /// Minimum gap between the (ink) bottom of the upper limit, and the (ink) top of the base operator
    pub upper_limit_gap_min: MathValueRecord,
    /// Minimum distance between baseline of upper limit and (ink) top of the base operator
    pub upper_limit_baseline_rise_min: MathValueRecord,
    /// Minimum gap between (ink) top of the lower limit, and (ink) bottom of the base operator
    pub lower_limit_gap_min: MathValueRecord,
    /// Minimum distance between baseline of the lower limit and (ink) bottom of the base operator
    pub lower_limit_baseline_drop_min: MathValueRecord,
    /// Standard shift up applied to the top element of a stack
    pub stack_top_shift_up: MathValueRecord,
    /// Standard shift up applied to the top element of a stack in display style
    pub stack_top_display_style_shift_up: MathValueRecord,
    /// Standard shift down applied to the bottom element of a stack
    pub stack_bottom_shift_down: MathValueRecord,
    /// Standard shift down applied to the bottom element of a stack in display style
    pub stack_bottom_display_style_shift_down: MathValueRecord,
    /// Minimum gap between (ink) bottom of the top element of a stack, and the (ink) top of the bottom element
    pub stack_gap_min: MathValueRecord,
    /// Minimum gap between (ink) bottom of the top element of a stack, and the (ink) top of the bottom element in display style
    pub stack_display_style_gap_min: MathValueRecord,
    /// Standard shift up applied to the top element of the stretch stack.
    pub stretch_stack_top_shift_up: MathValueRecord,
    /// Standard shift down applied to the bottom element of the stretch stack.
    pub stretch_stack_bottom_shift_down: MathValueRecord,
    /// Minimum gap between the ink of the stretched element, and the (ink) bottom of the element above
    pub stretch_stack_gap_above_min: MathValueRecord,
    /// Minimum gap between the ink of the stretched element, and the (ink) top of the element below
    pub stretch_stack_gap_below_min: MathValueRecord,
    /// Standard shift up applied to the numerator
    pub fraction_numerator_shift_up: MathValueRecord,
    /// Standard shift up applied to the numerator in display style
    pub fraction_numerator_display_style_shift_up: MathValueRecord,
    /// Standard shift down applied to the denominator
    pub fraction_denominator_shift_down: MathValueRecord,
    /// Standard shift down applied to the denominator in display style
    pub fraction_denominator_display_style_shift_down: MathValueRecord,
    /// Minimum tolerated gap between the (ink) bottom of the numerator and the ink of the fraction bar
    pub fraction_numerator_gap_min: MathValueRecord,
    /// Minimum tolerated gap between the (ink) bottom of the numerator and the ink of the fraction bar in display style
    pub fraction_num_display_style_gap_min: MathValueRecord,
    /// Thickness of the fraction bar
    pub fraction_rule_thickness: MathValueRecord,
    /// Minimum tolerated gap between the (ink) top of the denominator and the ink of the fraction bar
    pub fraction_denominator_gap_min: MathValueRecord,
    /// Minimum tolerated gap between the (ink) top of the denominator and the ink of the fraction bar in display style
    pub fraction_denom_display_style_gap_min: MathValueRecord,
    /// Horizontal distance between the top and bottom elements of a skewed fraction
    pub skewed_fraction_horizontal_gap: MathValueRecord,
    /// Vertical distance between the ink of the top and bottom elements of a skewed fraction
    pub skewed_fraction_vertical_gap: MathValueRecord,
    /// Distance between the overbar and the (ink) top of the base
    pub overbar_vertical_gap: MathValueRecord,
    /// Thickness of overbar
    pub overbar_rule_thickness: MathValueRecord,
    /// Extra white space reserved above the overbar
    pub overbar_extra_ascender: MathValueRecord,
    /// Distance between underbar and (ink) bottom of the base
    pub underbar_vertical_gap: MathValueRecord,
    /// Thickness of underbar
    pub underbar_rule_thickness: MathValueRecord,
    /// Extra white space reserved below the underbar
    pub underbar_extra_descender: MathValueRecord,
    /// Space between the (ink) top of the expression and the bar over it
    pub radical_vertical_gap: MathValueRecord,
    /// Space between the (ink) top of the expression and the bar over it
    pub radical_display_style_vertical_gap: MathValueRecord,
    /// Thickness of the radical rule
    pub radical_rule_thickness: MathValueRecord,
    /// Extra white space reserved above the radical
    pub radical_extra_ascender: MathValueRecord,
    /// Extra horizontal kern before the degree of a radical, if such is present
    pub radical_kern_before_degree: MathValueRecord,
    /// Negative kern after the degree of a radical, if such is present
    pub radical_kern_after_degree: MathValueRecord,
    /// Height of the bottom of the radical degree, if such is present, in proportion to the height (ascender + descender) of the radical sign
    pub radical_degree_bottom_raise_percent: i16,
}

impl MathConstants {
    /// Construct a new `MathConstants`
    #[allow(clippy::too_many_arguments)]
    pub fn new(
        script_percent_scale_down: i16,
        script_script_percent_scale_down: i16,
        delimited_sub_formula_min_height: UfWord,
        display_operator_min_height: UfWord,
        math_leading: MathValueRecord,
        axis_height: MathValueRecord,
        accent_base_height: MathValueRecord,
        flattened_accent_base_height: MathValueRecord,
        subscript_shift_down: MathValueRecord,
        subscript_top_max: MathValueRecord,
        subscript_baseline_drop_min: MathValueRecord,
        superscript_shift_up: MathValueRecord,
        superscript_shift_up_cramped: MathValueRecord,
        superscript_bottom_min: MathValueRecord,
        superscript_baseline_drop_max: MathValueRecord,
        sub_superscript_gap_min: MathValueRecord,
        superscript_bottom_max_with_subscript: MathValueRecord,
        space_after_script: MathValueRecord,
        upper_limit_gap_min: MathValueRecord,
        upper_limit_baseline_rise_min: MathValueRecord,
        lower_limit_gap_min: MathValueRecord,
        lower_limit_baseline_drop_min: MathValueRecord,
        stack_top_shift_up: MathValueRecord,
        stack_top_display_style_shift_up: MathValueRecord,
        stack_bottom_shift_down: MathValueRecord,
        stack_bottom_display_style_shift_down: MathValueRecord,
        stack_gap_min: MathValueRecord,
        stack_display_style_gap_min: MathValueRecord,
        stretch_stack_top_shift_up: MathValueRecord,
        stretch_stack_bottom_shift_down: MathValueRecord,
        stretch_stack_gap_above_min: MathValueRecord,
        stretch_stack_gap_below_min: MathValueRecord,
        fraction_numerator_shift_up: MathValueRecord,
        fraction_numerator_display_style_shift_up: MathValueRecord,
        fraction_denominator_shift_down: MathValueRecord,
        fraction_denominator_display_style_shift_down: MathValueRecord,
        fraction_numerator_gap_min: MathValueRecord,
        fraction_num_display_style_gap_min: MathValueRecord,
        fraction_rule_thickness: MathValueRecord,
        fraction_denominator_gap_min: MathValueRecord,
        fraction_denom_display_style_gap_min: MathValueRecord,
        skewed_fraction_horizontal_gap: MathValueRecord,
        skewed_fraction_vertical_gap: MathValueRecord,
        overbar_vertical_gap: MathValueRecord,
        overbar_rule_thickness: MathValueRecord,
        overbar_extra_ascender: MathValueRecord,
        underbar_vertical_gap: MathValueRecord,
        underbar_rule_thickness: MathValueRecord,
        underbar_extra_descender: MathValueRecord,
        radical_vertical_gap: MathValueRecord,
        radical_display_style_vertical_gap: MathValueRecord,
        radical_rule_thickness: MathValueRecord,
        radical_extra_ascender: MathValueRecord,
        radical_kern_before_degree: MathValueRecord,
        radical_kern_after_degree: MathValueRecord,
        radical_degree_bottom_raise_percent: i16,
    ) -> Self {
        Self {
            script_percent_scale_down,
            script_script_percent_scale_down,
            delimited_sub_formula_min_height,
            display_operator_min_height,
            math_leading,
            axis_height,
            accent_base_height,
            flattened_accent_base_height,
            subscript_shift_down,
            subscript_top_max,
            subscript_baseline_drop_min,
            superscript_shift_up,
            superscript_shift_up_cramped,
            superscript_bottom_min,
            superscript_baseline_drop_max,
            sub_superscript_gap_min,
            superscript_bottom_max_with_subscript,
            space_after_script,
            upper_limit_gap_min,
            upper_limit_baseline_rise_min,
            lower_limit_gap_min,
            lower_limit_baseline_drop_min,
            stack_top_shift_up,
            stack_top_display_style_shift_up,
            stack_bottom_shift_down,
            stack_bottom_display_style_shift_down,
            stack_gap_min,
            stack_display_style_gap_min,
            stretch_stack_top_shift_up,
            stretch_stack_bottom_shift_down,
            stretch_stack_gap_above_min,
            stretch_stack_gap_below_min,
            fraction_numerator_shift_up,
            fraction_numerator_display_style_shift_up,
            fraction_denominator_shift_down,
            fraction_denominator_display_style_shift_down,
            fraction_numerator_gap_min,
            fraction_num_display_style_gap_min,
            fraction_rule_thickness,
            fraction_denominator_gap_min,
            fraction_denom_display_style_gap_min,
            skewed_fraction_horizontal_gap,
            skewed_fraction_vertical_gap,
            overbar_vertical_gap,
            overbar_rule_thickness,
            overbar_extra_ascender,
            underbar_vertical_gap,
            underbar_rule_thickness,
            underbar_extra_descender,
            radical_vertical_gap,
            radical_display_style_vertical_gap,
            radical_rule_thickness,
            radical_extra_ascender,
            radical_kern_before_degree,
            radical_kern_after_degree,
            radical_degree_bottom_raise_percent,
        }
    }
}

impl FontWrite for MathConstants {
    fn write_into(&self, writer: &mut TableWriter) {
        self.script_percent_scale_down.write_into(writer);
        self.script_script_percent_scale_down.write_into(writer);
        self.delimited_sub_formula_min_height.write_into(writer);
        self.display_operator_min_height.write_into(writer);
        self.math_leading.write_into(writer);
        self.axis_height.write_into(writer);
        self.accent_base_height.write_into(writer);
        self.flattened_accent_base_height.write_into(writer);
        self.subscript_shift_down.write_into(writer);
        self.subscript_top_max.write_into(writer);
        self.subscript_baseline_drop_min.write_into(writer);
        self.superscript_shift_up.write_into(writer);
        self.superscript_shift_up_cramped.write_into(writer);
        self.superscript_bottom_min.write_into(writer);
        self.superscript_baseline_drop_max.write_into(writer);
        self.sub_superscript_gap_min.write_into(writer);
        self.superscript_bottom_max_with_subscript
            .write_into(writer);
        self.space_after_script.write_into(writer);
        self.upper_limit_gap_min.write_into(writer);
        self.upper_limit_baseline_rise_min.write_into(writer);
        self.lower_limit_gap_min.write_into(writer);
        self.lower_limit_baseline_drop_min.write_into(writer);
        self.stack_top_shift_up.write_into(writer);
        self.stack_top_display_style_shift_up.write_into(writer);
        self.stack_bottom_shift_down.write_into(writer);
        self.stack_bottom_display_style_shift_down
            .write_into(writer);
        self.stack_gap_min.write_into(writer);
        self.stack_display_style_gap_min.write_into(writer);
        self.stretch_stack_top_shift_up.write_into(writer);
        self.stretch_stack_bottom_shift_down.write_into(writer);
        self.stretch_stack_gap_above_min.write_into(writer);
        self.stretch_stack_gap_below_min.write_into(writer);
        self.fraction_numerator_shift_up.write_into(writer);
        self.fraction_numerator_display_style_shift_up
            .write_into(writer);
        self.fraction_denominator_shift_down.write_into(writer);
        self.fraction_denominator_display_style_shift_down
            .write_into(writer);
        self.fraction_numerator_gap_min.write_into(writer);
        self.fraction_num_display_style_gap_min.write_into(writer);
        self.fraction_rule_thickness.write_into(writer);
        self.fraction_denominator_gap_min.write_into(writer);
        self.fraction_denom_display_style_gap_min.write_into(writer);
        self.skewed_fraction_horizontal_gap.write_into(writer);
        self.skewed_fraction_vertical_gap.write_into(writer);
        self.overbar_vertical_gap.write_into(writer);
        self.overbar_rule_thickness.write_into(writer);
        self.overbar_extra_ascender.write_into(writer);
        self.underbar_vertical_gap.write_into(writer);
        self.underbar_rule_thickness.write_into(writer);
        self.underbar_extra_descender.write_into(writer);
        self.radical_vertical_gap.write_into(writer);
        self.radical_display_style_vertical_gap.write_into(writer);
        self.radical_rule_thickness.write_into(writer);
        self.radical_extra_ascender.write_into(writer);
        self.radical_kern_before_degree.write_into(writer);
        self.radical_kern_after_degree.write_into(writer);
        self.radical_degree_bottom_raise_percent.write_into(writer);
    }
    fn table_type(&self) -> TableType {
        TableType::Named("MathConstants")
    }
}

impl Validate for MathConstants {
    fn validate_impl(&self, _ctx: &mut ValidationCtx) {}
}

impl<'a> FromObjRef<read_fonts::tables::math::MathConstants<'a>> for MathConstants {
    fn from_obj_ref(obj: &read_fonts::tables::math::MathConstants<'a>, _: FontData) -> Self {
        let offset_data = obj.offset_data();
        MathConstants {
            script_percent_scale_down: obj.script_percent_scale_down(),
            script_script_percent_scale_down: obj.script_script_percent_scale_down(),
            delimited_sub_formula_min_height: obj.delimited_sub_formula_min_height(),
            display_operator_min_height: obj.display_operator_min_height(),
            math_leading: obj.math_leading().to_owned_obj(offset_data),
            axis_height: obj.axis_height().to_owned_obj(offset_data),
            accent_base_height: obj.accent_base_height().to_owned_obj(offset_data),
            flattened_accent_base_height: obj
                .flattened_accent_base_height()
                .to_owned_obj(offset_data),
            subscript_shift_down: obj.subscript_shift_down().to_owned_obj(offset_data),
            subscript_top_max: obj.subscript_top_max().to_owned_obj(offset_data),
            subscript_baseline_drop_min: obj
                .subscript_baseline_drop_min()
                .to_owned_obj(offset_data),
            superscript_shift_up: obj.superscript_shift_up().to_owned_obj(offset_data),
            superscript_shift_up_cramped: obj
                .superscript_shift_up_cramped()
                .to_owned_obj(offset_data),
            superscript_bottom_min: obj.superscript_bottom_min().to_owned_obj(offset_data),
            superscript_baseline_drop_max: obj
                .superscript_baseline_drop_max()
                .to_owned_obj(offset_data),
            sub_superscript_gap_min: obj.sub_superscript_gap_min().to_owned_obj(offset_data),
            superscript_bottom_max_with_subscript: obj
                .superscript_bottom_max_with_subscript()
                .to_owned_obj(offset_data),
            space_after_script: obj.space_after_script().to_owned_obj(offset_data),
            upper_limit_gap_min: obj.upper_limit_gap_min().to_owned_obj(offset_data),
            upper_limit_baseline_rise_min: obj
                .upper_limit_baseline_rise_min()
                .to_owned_obj(offset_data),
            lower_limit_gap_min: obj.lower_limit_gap_min().to_owned_obj(offset_data),
            lower_limit_baseline_drop_min: obj
                .lower_limit_baseline_drop_min()
                .to_owned_obj(offset_data),
            stack_top_shift_up: obj.stack_top_shift_up().to_owned_obj(offset_data),
            stack_top_display_style_shift_up: obj
                .stack_top_display_style_shift_up()
                .to_owned_obj(offset_data),
            stack_bottom_shift_down: obj.stack_bottom_shift_down().to_owned_obj(offset_data),
            stack_bottom_display_style_shift_down: obj
                .stack_bottom_display_style_shift_down()
                .to_owned_obj(offset_data),
            stack_gap_min: obj.stack_gap_min().to_owned_obj(offset_data),
            stack_display_style_gap_min: obj
                .stack_display_style_gap_min()
                .to_owned_obj(offset_data),
            stretch_stack_top_shift_up: obj.stretch_stack_top_shift_up().to_owned_obj(offset_data),
            stretch_stack_bottom_shift_down: obj
                .stretch_stack_bottom_shift_down()
                .to_owned_obj(offset_data),
            stretch_stack_gap_above_min: obj
                .stretch_stack_gap_above_min()
                .to_owned_obj(offset_data),
            stretch_stack_gap_below_min: obj
                .stretch_stack_gap_below_min()
                .to_owned_obj(offset_data),
            fraction_numerator_shift_up: obj
                .fraction_numerator_shift_up()
                .to_owned_obj(offset_data),
            fraction_numerator_display_style_shift_up: obj
                .fraction_numerator_display_style_shift_up()
                .to_owned_obj(offset_data),
            fraction_denominator_shift_down: obj
                .fraction_denominator_shift_down()
                .to_owned_obj(offset_data),
            fraction_denominator_display_style_shift_down: obj
                .fraction_denominator_display_style_shift_down()
                .to_owned_obj(offset_data),
            fraction_numerator_gap_min: obj.fraction_numerator_gap_min().to_owned_obj(offset_data),
            fraction_num_display_style_gap_min: obj
                .fraction_num_display_style_gap_min()
                .to_owned_obj(offset_data),
            fraction_rule_thickness: obj.fraction_rule_thickness().to_owned_obj(offset_data),
            fraction_denominator_gap_min: obj
                .fraction_denominator_gap_min()
                .to_owned_obj(offset_data),
            fraction_denom_display_style_gap_min: obj
                .fraction_denom_display_style_gap_min()
                .to_owned_obj(offset_data),
            skewed_fraction_horizontal_gap: obj
                .skewed_fraction_horizontal_gap()
                .to_owned_obj(offset_data),
            skewed_fraction_vertical_gap: obj
                .skewed_fraction_vertical_gap()
                .to_owned_obj(offset_data),
            overbar_vertical_gap: obj.overbar_vertical_gap().to_owned_obj(offset_data),
            overbar_rule_thickness: obj.overbar_rule_thickness().to_owned_obj(offset_data),
            overbar_extra_ascender: obj.overbar_extra_ascender().to_owned_obj(offset_data),
            underbar_vertical_gap: obj.underbar_vertical_gap().to_owned_obj(offset_data),
            underbar_rule_thickness: obj.underbar_rule_thickness().to_owned_obj(offset_data),
            underbar_extra_descender: obj.underbar_extra_descender().to_owned_obj(offset_data),
            radical_vertical_gap: obj.radical_vertical_gap().to_owned_obj(offset_data),
            radical_display_style_vertical_gap: obj
                .radical_display_style_vertical_gap()
                .to_owned_obj(offset_data),
            radical_rule_thickness: obj.radical_rule_thickness().to_owned_obj(offset_data),
            radical_extra_ascender: obj.radical_extra_ascender().to_owned_obj(offset_data),
            radical_kern_before_degree: obj.radical_kern_before_degree().to_owned_obj(offset_data),
            radical_kern_after_degree: obj.radical_kern_after_degree().to_owned_obj(offset_data),
            radical_degree_bottom_raise_percent: obj.radical_degree_bottom_raise_percent(),
        }
    }
}

#[allow(clippy::needless_lifetimes)]
impl<'a> FromTableRef<read_fonts::tables::math::MathConstants<'a>> for MathConstants {}

impl<'a> FontRead<'a> for MathConstants {
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        <read_fonts::tables::math::MathConstants as FontRead>::read(data)
            .map(|x| x.to_owned_table())
    }
}

/// [MathGlyphInfo](https://learn.microsoft.com/en-gb/typography/opentype/spec/math#mathglyphinfo-table)
#[derive(Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct MathGlyphInfo {
    /// Offset to MathItalicsCorrectionInfo table, from the beginning of the MathGlyphInfo table
    pub math_italics_correction_info: OffsetMarker<MathItalicsCorrectionInfo>,
    /// Offset to MathTopAccentAttachment table, from the beginning of the MathGlyphInfo table
    pub math_top_accent_attachment: OffsetMarker<MathTopAccentAttachment>,
    /// Offset to ExtendedShapes coverage table, from the beginning of the MathGlyphInfo table
    pub extended_shape_coverage: NullableOffsetMarker<CoverageTable>,
    /// Offset to MathKernInfo table, from the beginning of the MathGlyphInfo table
    pub math_kern_info: OffsetMarker<MathKernInfo>,
}

impl MathGlyphInfo {
    /// Construct a new `MathGlyphInfo`
    pub fn new(
        math_italics_correction_info: MathItalicsCorrectionInfo,
        math_top_accent_attachment: MathTopAccentAttachment,
        extended_shape_coverage: Option<CoverageTable>,
        math_kern_info: MathKernInfo,
    ) -> Self {
        Self {
            math_italics_correction_info: math_italics_correction_info.into(),
            math_top_accent_attachment: math_top_accent_attachment.into(),
            extended_shape_coverage: extended_shape_coverage.into(),
            math_kern_info: math_kern_info.into(),
        }
    }
}

impl FontWrite for MathGlyphInfo {
    fn write_into(&self, writer: &mut TableWriter) {
        self.math_italics_correction_info.write_into(writer);
        self.math_top_accent_attachment.write_into(writer);
        self.extended_shape_coverage.write_into(writer);
        self.math_kern_info.write_into(writer);
    }
    fn table_type(&self) -> TableType {
        TableType::Named("MathGlyphInfo")
    }
}

impl Validate for MathGlyphInfo {
    fn validate_impl(&self, ctx: &mut ValidationCtx) {
        ctx.in_table("MathGlyphInfo", |ctx| {
            ctx.in_field("math_italics_correction_info", |ctx| {
                self.math_italics_correction_info.validate_impl(ctx);
            });
            ctx.in_field("math_top_accent_attachment", |ctx| {
                self.math_top_accent_attachment.validate_impl(ctx);
            });
            ctx.in_field("extended_shape_coverage", |ctx| {
                self.extended_shape_coverage.validate_impl(ctx);
            });
            ctx.in_field("math_kern_info", |ctx| {
                self.math_kern_info.validate_impl(ctx);
            });
        })
    }
}

impl<'a> FromObjRef<read_fonts::tables::math::MathGlyphInfo<'a>> for MathGlyphInfo {
    fn from_obj_ref(obj: &read_fonts::tables::math::MathGlyphInfo<'a>, _: FontData) -> Self {
        MathGlyphInfo {
            math_italics_correction_info: obj.math_italics_correction_info().to_owned_table(),
            math_top_accent_attachment: obj.math_top_accent_attachment().to_owned_table(),
            extended_shape_coverage: obj.extended_shape_coverage().to_owned_table(),
            math_kern_info: obj.math_kern_info().to_owned_table(),
        }
    }
}

#[allow(clippy::needless_lifetimes)]
impl<'a> FromTableRef<read_fonts::tables::math::MathGlyphInfo<'a>> for MathGlyphInfo {}

impl<'a> FontRead<'a> for MathGlyphInfo {
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        <read_fonts::tables::math::MathGlyphInfo as FontRead>::read(data)
            .map(|x| x.to_owned_table())
    }
}

/// [MathItalicsCorrectionInfo](https://learn.microsoft.com/en-gb/typography/opentype/spec/math#mathitalicscorrectioninfo-table)
#[derive(Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct MathItalicsCorrectionInfo {
    /// Offset to Coverage table, from the beginning of MathItalicsCorrectionInfo table
    pub coverage: OffsetMarker<CoverageTable>,
    /// Array of MathValueRecords defining italics correction values for each covered glyph
    pub italics_correction: Vec<MathValueRecord>,
}

impl MathItalicsCorrectionInfo {
    /// Construct a new `MathItalicsCorrectionInfo`
    pub fn new(coverage: CoverageTable, italics_correction: Vec<MathValueRecord>) -> Self {
        Self {
            coverage: coverage.into(),
            italics_correction: italics_correction.into_iter().map(Into::into).collect(),
        }
    }
}

impl FontWrite for MathItalicsCorrectionInfo {
    #[allow(clippy::unnecessary_cast)]
    fn write_into(&self, writer: &mut TableWriter) {
        self.coverage.write_into(writer);
        (u16::try_from(array_len(&self.italic_correction_values)).unwrap()).write_into(writer);
        self.italics_correction.write_into(writer);
    }
    fn table_type(&self) -> TableType {
        TableType::Named("MathItalicsCorrectionInfo")
    }
}

impl Validate for MathItalicsCorrectionInfo {
    fn validate_impl(&self, ctx: &mut ValidationCtx) {
        ctx.in_table("MathItalicsCorrectionInfo", |ctx| {
            ctx.in_field("coverage", |ctx| {
                self.coverage.validate_impl(ctx);
            });
            ctx.in_field("italics_correction", |ctx| {
                if self.italics_correction.len() > (u16::MAX as usize) {
                    ctx.report("array exceeds max length");
                }
                self.italics_correction.validate_impl(ctx);
            });
        })
    }
}

impl<'a> FromObjRef<read_fonts::tables::math::MathItalicsCorrectionInfo<'a>>
    for MathItalicsCorrectionInfo
{
    fn from_obj_ref(
        obj: &read_fonts::tables::math::MathItalicsCorrectionInfo<'a>,
        _: FontData,
    ) -> Self {
        let offset_data = obj.offset_data();
        MathItalicsCorrectionInfo {
            coverage: obj.coverage().to_owned_table(),
            italics_correction: obj.italics_correction().to_owned_obj(offset_data),
        }
    }
}

#[allow(clippy::needless_lifetimes)]
impl<'a> FromTableRef<read_fonts::tables::math::MathItalicsCorrectionInfo<'a>>
    for MathItalicsCorrectionInfo
{
}

impl<'a> FontRead<'a> for MathItalicsCorrectionInfo {
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        <read_fonts::tables::math::MathItalicsCorrectionInfo as FontRead>::read(data)
            .map(|x| x.to_owned_table())
    }
}

/// [MathTopAccentAttachment](https://learn.microsoft.com/en-gb/typography/opentype/spec/math#mathtopaccentattachment-table)
#[derive(Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct MathTopAccentAttachment {
    /// Offset to Coverage table, from the beginning of MathTopAccentAttachment table
    pub top_accent_coverage: OffsetMarker<CoverageTable>,
    /// Array of MathValueRecords defining top accent attachment values for each covered glyph
    pub top_accent_attachment: Vec<MathValueRecord>,
}

impl MathTopAccentAttachment {
    /// Construct a new `MathTopAccentAttachment`
    pub fn new(
        top_accent_coverage: CoverageTable,
        top_accent_attachment: Vec<MathValueRecord>,
    ) -> Self {
        Self {
            top_accent_coverage: top_accent_coverage.into(),
            top_accent_attachment: top_accent_attachment.into_iter().map(Into::into).collect(),
        }
    }
}

impl FontWrite for MathTopAccentAttachment {
    #[allow(clippy::unnecessary_cast)]
    fn write_into(&self, writer: &mut TableWriter) {
        self.top_accent_coverage.write_into(writer);
        (u16::try_from(array_len(&self.top_accent_attachment_values)).unwrap()).write_into(writer);
        self.top_accent_attachment.write_into(writer);
    }
    fn table_type(&self) -> TableType {
        TableType::Named("MathTopAccentAttachment")
    }
}

impl Validate for MathTopAccentAttachment {
    fn validate_impl(&self, ctx: &mut ValidationCtx) {
        ctx.in_table("MathTopAccentAttachment", |ctx| {
            ctx.in_field("top_accent_coverage", |ctx| {
                self.top_accent_coverage.validate_impl(ctx);
            });
            ctx.in_field("top_accent_attachment", |ctx| {
                if self.top_accent_attachment.len() > (u16::MAX as usize) {
                    ctx.report("array exceeds max length");
                }
                self.top_accent_attachment.validate_impl(ctx);
            });
        })
    }
}

impl<'a> FromObjRef<read_fonts::tables::math::MathTopAccentAttachment<'a>>
    for MathTopAccentAttachment
{
    fn from_obj_ref(
        obj: &read_fonts::tables::math::MathTopAccentAttachment<'a>,
        _: FontData,
    ) -> Self {
        let offset_data = obj.offset_data();
        MathTopAccentAttachment {
            top_accent_coverage: obj.top_accent_coverage().to_owned_table(),
            top_accent_attachment: obj.top_accent_attachment().to_owned_obj(offset_data),
        }
    }
}

#[allow(clippy::needless_lifetimes)]
impl<'a> FromTableRef<read_fonts::tables::math::MathTopAccentAttachment<'a>>
    for MathTopAccentAttachment
{
}

impl<'a> FontRead<'a> for MathTopAccentAttachment {
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        <read_fonts::tables::math::MathTopAccentAttachment as FontRead>::read(data)
            .map(|x| x.to_owned_table())
    }
}

/// [MathKernInfo](https://learn.microsoft.com/en-gb/typography/opentype/spec/math#mathkerninfo-table)
#[derive(Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct MathKernInfo {
    /// Offset to Coverage table, from the beginning of the MathKernInfo table
    pub coverage: OffsetMarker<CoverageTable>,
    /// Array of MathKernInfoRecords
    pub math_kern_info: Vec<MathKernInfoRecord>,
}

impl MathKernInfo {
    /// Construct a new `MathKernInfo`
    pub fn new(coverage: CoverageTable, math_kern_info: Vec<MathKernInfoRecord>) -> Self {
        Self {
            coverage: coverage.into(),
            math_kern_info: math_kern_info.into_iter().map(Into::into).collect(),
        }
    }
}

impl FontWrite for MathKernInfo {
    #[allow(clippy::unnecessary_cast)]
    fn write_into(&self, writer: &mut TableWriter) {
        self.coverage.write_into(writer);
        (u16::try_from(array_len(&self.kern_info_records)).unwrap()).write_into(writer);
        self.math_kern_info.write_into(writer);
    }
    fn table_type(&self) -> TableType {
        TableType::Named("MathKernInfo")
    }
}

impl Validate for MathKernInfo {
    fn validate_impl(&self, ctx: &mut ValidationCtx) {
        ctx.in_table("MathKernInfo", |ctx| {
            ctx.in_field("coverage", |ctx| {
                self.coverage.validate_impl(ctx);
            });
            ctx.in_field("math_kern_info", |ctx| {
                if self.math_kern_info.len() > (u16::MAX as usize) {
                    ctx.report("array exceeds max length");
                }
                self.math_kern_info.validate_impl(ctx);
            });
        })
    }
}

impl<'a> FromObjRef<read_fonts::tables::math::MathKernInfo<'a>> for MathKernInfo {
    fn from_obj_ref(obj: &read_fonts::tables::math::MathKernInfo<'a>, _: FontData) -> Self {
        let offset_data = obj.offset_data();
        MathKernInfo {
            coverage: obj.coverage().to_owned_table(),
            math_kern_info: obj.math_kern_info().to_owned_obj(offset_data),
        }
    }
}

#[allow(clippy::needless_lifetimes)]
impl<'a> FromTableRef<read_fonts::tables::math::MathKernInfo<'a>> for MathKernInfo {}

impl<'a> FontRead<'a> for MathKernInfo {
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        <read_fonts::tables::math::MathKernInfo as FontRead>::read(data).map(|x| x.to_owned_table())
    }
}

/// [MathKernInfoRecord](https://learn.microsoft.com/en-gb/typography/opentype/spec/math#mathkerninfo-table)
#[derive(Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct MathKernInfoRecord {
    /// Offset to MathKern table for top right corner, from the beginning of the MathKernInfo table
    pub top_right_math_kern: OffsetMarker<MathKern>,
    /// Offset to MathKern table for top left corner, from the beginning of the MathKernInfo table
    pub top_left_math_kern: OffsetMarker<MathKern>,
    /// Offset to MathKern table for bottom right corner, from the beginning of the MathKernInfo table
    pub bottom_right_math_kern: OffsetMarker<MathKern>,
    /// Offset to MathKern table for bottom left corner, from the beginning of the MathKernInfo table
    pub bottom_left_math_kern: OffsetMarker<MathKern>,
}

impl MathKernInfoRecord {
    /// Construct a new `MathKernInfoRecord`
    pub fn new(
        top_right_math_kern: MathKern,
        top_left_math_kern: MathKern,
        bottom_right_math_kern: MathKern,
        bottom_left_math_kern: MathKern,
    ) -> Self {
        Self {
            top_right_math_kern: top_right_math_kern.into(),
            top_left_math_kern: top_left_math_kern.into(),
            bottom_right_math_kern: bottom_right_math_kern.into(),
            bottom_left_math_kern: bottom_left_math_kern.into(),
        }
    }
}

impl FontWrite for MathKernInfoRecord {
    fn write_into(&self, writer: &mut TableWriter) {
        self.top_right_math_kern.write_into(writer);
        self.top_left_math_kern.write_into(writer);
        self.bottom_right_math_kern.write_into(writer);
        self.bottom_left_math_kern.write_into(writer);
    }
    fn table_type(&self) -> TableType {
        TableType::Named("MathKernInfoRecord")
    }
}

impl Validate for MathKernInfoRecord {
    fn validate_impl(&self, ctx: &mut ValidationCtx) {
        ctx.in_table("MathKernInfoRecord", |ctx| {
            ctx.in_field("top_right_math_kern", |ctx| {
                self.top_right_math_kern.validate_impl(ctx);
            });
            ctx.in_field("top_left_math_kern", |ctx| {
                self.top_left_math_kern.validate_impl(ctx);
            });
            ctx.in_field("bottom_right_math_kern", |ctx| {
                self.bottom_right_math_kern.validate_impl(ctx);
            });
            ctx.in_field("bottom_left_math_kern", |ctx| {
                self.bottom_left_math_kern.validate_impl(ctx);
            });
        })
    }
}

impl FromObjRef<read_fonts::tables::math::MathKernInfoRecord> for MathKernInfoRecord {
    fn from_obj_ref(
        obj: &read_fonts::tables::math::MathKernInfoRecord,
        offset_data: FontData,
    ) -> Self {
        MathKernInfoRecord {
            top_right_math_kern: obj.top_right_math_kern(offset_data).to_owned_table(),
            top_left_math_kern: obj.top_left_math_kern(offset_data).to_owned_table(),
            bottom_right_math_kern: obj.bottom_right_math_kern(offset_data).to_owned_table(),
            bottom_left_math_kern: obj.bottom_left_math_kern(offset_data).to_owned_table(),
        }
    }
}

/// [MathKern](https://learn.microsoft.com/en-gb/typography/opentype/spec/math#mathkerninfo-table) table
#[derive(Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct MathKern {
    /// Array of correction heights, in design units, sorted from lowest to highest
    pub correction_heights: Vec<MathValueRecord>,
    /// Array of kerning values for different height ranges
    pub kern_values: Vec<MathValueRecord>,
}

impl MathKern {
    /// Construct a new `MathKern`
    pub fn new(
        correction_heights: Vec<MathValueRecord>,
        kern_values: Vec<MathValueRecord>,
    ) -> Self {
        Self {
            correction_heights: correction_heights.into_iter().map(Into::into).collect(),
            kern_values: kern_values.into_iter().map(Into::into).collect(),
        }
    }
}

impl FontWrite for MathKern {
    #[allow(clippy::unnecessary_cast)]
    fn write_into(&self, writer: &mut TableWriter) {
        (u16::try_from(array_len(&self.correction_heights)).unwrap()).write_into(writer);
        self.correction_heights.write_into(writer);
        self.kern_values.write_into(writer);
    }
    fn table_type(&self) -> TableType {
        TableType::Named("MathKern")
    }
}

impl Validate for MathKern {
    fn validate_impl(&self, ctx: &mut ValidationCtx) {
        ctx.in_table("MathKern", |ctx| {
            ctx.in_field("correction_heights", |ctx| {
                if self.correction_heights.len() > (u16::MAX as usize) {
                    ctx.report("array exceeds max length");
                }
                self.correction_heights.validate_impl(ctx);
            });
            ctx.in_field("kern_values", |ctx| {
                self.kern_values.validate_impl(ctx);
            });
        })
    }
}

impl<'a> FromObjRef<read_fonts::tables::math::MathKern<'a>> for MathKern {
    fn from_obj_ref(obj: &read_fonts::tables::math::MathKern<'a>, _: FontData) -> Self {
        let offset_data = obj.offset_data();
        MathKern {
            correction_heights: obj.correction_heights().to_owned_obj(offset_data),
            kern_values: obj.kern_values().to_owned_obj(offset_data),
        }
    }
}

#[allow(clippy::needless_lifetimes)]
impl<'a> FromTableRef<read_fonts::tables::math::MathKern<'a>> for MathKern {}

impl<'a> FontRead<'a> for MathKern {
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        <read_fonts::tables::math::MathKern as FontRead>::read(data).map(|x| x.to_owned_table())
    }
}

/// [MathVariants](https://learn.microsoft.com/en-gb/typography/opentype/spec/math#mathvariants-table) table
#[derive(Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct MathVariants {
    /// Minimum overlap of connecting glyphs during glyph construction, in design units
    pub min_connector_overlap: UfWord,
    /// Offset to Coverage table, from the beginning of the MathVariants table
    pub vert_glyph_coverage: OffsetMarker<CoverageTable>,
    /// Offset to Coverage table, from the beginning of the MathVariants table
    pub horiz_glyph_coverage: OffsetMarker<CoverageTable>,
    /// Array of offsets to MathGlyphConstruction tables, from the beginning of the MathVariants table, for shapes growing in the vertical direction
    pub vert_glyph_constructions: Vec<OffsetMarker<MathGlyphConstruction>>,
    /// Array of offsets to MathGlyphConstruction tables, from the beginning of the MathVariants table, for shapes growing in the horizontal direction
    pub horiz_glyph_constructions: Vec<OffsetMarker<MathGlyphConstruction>>,
}

impl MathVariants {
    /// Construct a new `MathVariants`
    pub fn new(
        min_connector_overlap: UfWord,
        vert_glyph_coverage: CoverageTable,
        horiz_glyph_coverage: CoverageTable,
        vert_glyph_constructions: Vec<MathGlyphConstruction>,
        horiz_glyph_constructions: Vec<MathGlyphConstruction>,
    ) -> Self {
        Self {
            min_connector_overlap,
            vert_glyph_coverage: vert_glyph_coverage.into(),
            horiz_glyph_coverage: horiz_glyph_coverage.into(),
            vert_glyph_constructions: vert_glyph_constructions
                .into_iter()
                .map(Into::into)
                .collect(),
            horiz_glyph_constructions: horiz_glyph_constructions
                .into_iter()
                .map(Into::into)
                .collect(),
        }
    }
}

impl FontWrite for MathVariants {
    #[allow(clippy::unnecessary_cast)]
    fn write_into(&self, writer: &mut TableWriter) {
        self.min_connector_overlap.write_into(writer);
        self.vert_glyph_coverage.write_into(writer);
        self.horiz_glyph_coverage.write_into(writer);
        (u16::try_from(array_len(&self.vert_glyph_constructions)).unwrap()).write_into(writer);
        (u16::try_from(array_len(&self.horiz_glyph_constructions)).unwrap()).write_into(writer);
        self.vert_glyph_constructions.write_into(writer);
        self.horiz_glyph_constructions.write_into(writer);
    }
    fn table_type(&self) -> TableType {
        TableType::Named("MathVariants")
    }
}

impl Validate for MathVariants {
    fn validate_impl(&self, ctx: &mut ValidationCtx) {
        ctx.in_table("MathVariants", |ctx| {
            ctx.in_field("vert_glyph_coverage", |ctx| {
                self.vert_glyph_coverage.validate_impl(ctx);
            });
            ctx.in_field("horiz_glyph_coverage", |ctx| {
                self.horiz_glyph_coverage.validate_impl(ctx);
            });
            ctx.in_field("vert_glyph_constructions", |ctx| {
                if self.vert_glyph_constructions.len() > (u16::MAX as usize) {
                    ctx.report("array exceeds max length");
                }
                self.vert_glyph_constructions.validate_impl(ctx);
            });
            ctx.in_field("horiz_glyph_constructions", |ctx| {
                if self.horiz_glyph_constructions.len() > (u16::MAX as usize) {
                    ctx.report("array exceeds max length");
                }
                self.horiz_glyph_constructions.validate_impl(ctx);
            });
        })
    }
}

impl<'a> FromObjRef<read_fonts::tables::math::MathVariants<'a>> for MathVariants {
    fn from_obj_ref(obj: &read_fonts::tables::math::MathVariants<'a>, _: FontData) -> Self {
        MathVariants {
            min_connector_overlap: obj.min_connector_overlap(),
            vert_glyph_coverage: obj.vert_glyph_coverage().to_owned_table(),
            horiz_glyph_coverage: obj.horiz_glyph_coverage().to_owned_table(),
            vert_glyph_constructions: obj.vert_glyph_constructions().to_owned_table(),
            horiz_glyph_constructions: obj.horiz_glyph_constructions().to_owned_table(),
        }
    }
}

#[allow(clippy::needless_lifetimes)]
impl<'a> FromTableRef<read_fonts::tables::math::MathVariants<'a>> for MathVariants {}

impl<'a> FontRead<'a> for MathVariants {
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        <read_fonts::tables::math::MathVariants as FontRead>::read(data).map(|x| x.to_owned_table())
    }
}

/// The [MathGlyphConstruction](https://learn.microsoft.com/en-gb/typography/opentype/spec/math#mathglyphconstruction-table) table
#[derive(Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct MathGlyphConstruction {
    /// Offset to the GlyphAssembly table for this shape, from the beginning of the MathGlyphConstruction table
    pub glyph_assembly: NullableOffsetMarker<GlyphAssembly>,
    /// MathGlyphVariantRecords for alternative variants of the glyphs
    pub math_glyph_variant_records: Vec<MathGlyphVariantRecord>,
}

impl MathGlyphConstruction {
    /// Construct a new `MathGlyphConstruction`
    pub fn new(
        glyph_assembly: Option<GlyphAssembly>,
        math_glyph_variant_records: Vec<MathGlyphVariantRecord>,
    ) -> Self {
        Self {
            glyph_assembly: glyph_assembly.into(),
            math_glyph_variant_records: math_glyph_variant_records
                .into_iter()
                .map(Into::into)
                .collect(),
        }
    }
}

impl FontWrite for MathGlyphConstruction {
    #[allow(clippy::unnecessary_cast)]
    fn write_into(&self, writer: &mut TableWriter) {
        self.glyph_assembly.write_into(writer);
        (u16::try_from(array_len(&self.math_glyph_variant_records)).unwrap()).write_into(writer);
        self.math_glyph_variant_records.write_into(writer);
    }
    fn table_type(&self) -> TableType {
        TableType::Named("MathGlyphConstruction")
    }
}

impl Validate for MathGlyphConstruction {
    fn validate_impl(&self, ctx: &mut ValidationCtx) {
        ctx.in_table("MathGlyphConstruction", |ctx| {
            ctx.in_field("glyph_assembly", |ctx| {
                self.glyph_assembly.validate_impl(ctx);
            });
            ctx.in_field("math_glyph_variant_records", |ctx| {
                if self.math_glyph_variant_records.len() > (u16::MAX as usize) {
                    ctx.report("array exceeds max length");
                }
                self.math_glyph_variant_records.validate_impl(ctx);
            });
        })
    }
}

impl<'a> FromObjRef<read_fonts::tables::math::MathGlyphConstruction<'a>> for MathGlyphConstruction {
    fn from_obj_ref(
        obj: &read_fonts::tables::math::MathGlyphConstruction<'a>,
        _: FontData,
    ) -> Self {
        let offset_data = obj.offset_data();
        MathGlyphConstruction {
            glyph_assembly: obj.glyph_assembly().to_owned_table(),
            math_glyph_variant_records: obj.math_glyph_variant_records().to_owned_obj(offset_data),
        }
    }
}

#[allow(clippy::needless_lifetimes)]
impl<'a> FromTableRef<read_fonts::tables::math::MathGlyphConstruction<'a>>
    for MathGlyphConstruction
{
}

impl<'a> FontRead<'a> for MathGlyphConstruction {
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        <read_fonts::tables::math::MathGlyphConstruction as FontRead>::read(data)
            .map(|x| x.to_owned_table())
    }
}

/// [MathGlyphVariantRecord](https://learn.microsoft.com/en-gb/typography/opentype/spec/math#mathglyphconstruction-table)
#[derive(Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct MathGlyphVariantRecord {
    /// Glyph ID for the variant
    pub glyph_id: GlyphId16,
    /// Advance width/height, in design units, of the variant, in the direction of requested glyph extension
    pub advance_measurement: UfWord,
}

impl MathGlyphVariantRecord {
    /// Construct a new `MathGlyphVariantRecord`
    pub fn new(glyph_id: GlyphId16, advance_measurement: UfWord) -> Self {
        Self {
            glyph_id,
            advance_measurement,
        }
    }
}

impl FontWrite for MathGlyphVariantRecord {
    fn write_into(&self, writer: &mut TableWriter) {
        self.glyph_id.write_into(writer);
        self.advance_measurement.write_into(writer);
    }
    fn table_type(&self) -> TableType {
        TableType::Named("MathGlyphVariantRecord")
    }
}

impl Validate for MathGlyphVariantRecord {
    fn validate_impl(&self, _ctx: &mut ValidationCtx) {}
}

impl FromObjRef<read_fonts::tables::math::MathGlyphVariantRecord> for MathGlyphVariantRecord {
    fn from_obj_ref(obj: &read_fonts::tables::math::MathGlyphVariantRecord, _: FontData) -> Self {
        MathGlyphVariantRecord {
            glyph_id: obj.glyph_id(),
            advance_measurement: obj.advance_measurement(),
        }
    }
}

/// The [GlyphAssembly](https://learn.microsoft.com/en-gb/typography/opentype/spec/math#glyphassembly-table) table
#[derive(Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct GlyphAssembly {
    /// Italic correction value for the assembly, in design units
    pub italic_correction: MathValueRecord,
    /// Array of GlyphPart records, from left to right (for assemblies that extend horizontally) or bottom to top (for assemblies that extend vertically)
    pub part_records: Vec<GlyphPart>,
}

impl GlyphAssembly {
    /// Construct a new `GlyphAssembly`
    pub fn new(italic_correction: MathValueRecord, part_records: Vec<GlyphPart>) -> Self {
        Self {
            italic_correction,
            part_records: part_records.into_iter().map(Into::into).collect(),
        }
    }
}

impl FontWrite for GlyphAssembly {
    #[allow(clippy::unnecessary_cast)]
    fn write_into(&self, writer: &mut TableWriter) {
        self.italic_correction.write_into(writer);
        (u16::try_from(array_len(&self.part_records)).unwrap()).write_into(writer);
        self.part_records.write_into(writer);
    }
    fn table_type(&self) -> TableType {
        TableType::Named("GlyphAssembly")
    }
}

impl Validate for GlyphAssembly {
    fn validate_impl(&self, ctx: &mut ValidationCtx) {
        ctx.in_table("GlyphAssembly", |ctx| {
            ctx.in_field("part_records", |ctx| {
                if self.part_records.len() > (u16::MAX as usize) {
                    ctx.report("array exceeds max length");
                }
                self.part_records.validate_impl(ctx);
            });
        })
    }
}

impl<'a> FromObjRef<read_fonts::tables::math::GlyphAssembly<'a>> for GlyphAssembly {
    fn from_obj_ref(obj: &read_fonts::tables::math::GlyphAssembly<'a>, _: FontData) -> Self {
        let offset_data = obj.offset_data();
        GlyphAssembly {
            italic_correction: obj.italic_correction().to_owned_obj(offset_data),
            part_records: obj.part_records().to_owned_obj(offset_data),
        }
    }
}

#[allow(clippy::needless_lifetimes)]
impl<'a> FromTableRef<read_fonts::tables::math::GlyphAssembly<'a>> for GlyphAssembly {}

impl<'a> FontRead<'a> for GlyphAssembly {
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        <read_fonts::tables::math::GlyphAssembly as FontRead>::read(data)
            .map(|x| x.to_owned_table())
    }
}

#[derive(Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct GlyphPart {
    /// Glyph ID of the part
    pub glyph_id: GlyphId16,
    /// Advance width / height, in design units, of the straight bar connector material at the start of the glyph in the direction of the extension
    pub start_connector_length: UfWord,
    /// Advance width / height, in design units, of the straight bar connector material at the end of the glyph in the direction of the extension
    pub end_connector_length: UfWord,
    /// Full advance width/height for this part in the direction of the extension, in design units
    pub full_advance: UfWord,
    /// Part qualifiers
    pub part_flags: GlyphPartFlags,
}

impl GlyphPart {
    /// Construct a new `GlyphPart`
    pub fn new(
        glyph_id: GlyphId16,
        start_connector_length: UfWord,
        end_connector_length: UfWord,
        full_advance: UfWord,
        part_flags: GlyphPartFlags,
    ) -> Self {
        Self {
            glyph_id,
            start_connector_length,
            end_connector_length,
            full_advance,
            part_flags,
        }
    }
}

impl FontWrite for GlyphPart {
    fn write_into(&self, writer: &mut TableWriter) {
        self.glyph_id.write_into(writer);
        self.start_connector_length.write_into(writer);
        self.end_connector_length.write_into(writer);
        self.full_advance.write_into(writer);
        self.part_flags.write_into(writer);
    }
    fn table_type(&self) -> TableType {
        TableType::Named("GlyphPart")
    }
}

impl Validate for GlyphPart {
    fn validate_impl(&self, _ctx: &mut ValidationCtx) {}
}

impl FromObjRef<read_fonts::tables::math::GlyphPart> for GlyphPart {
    fn from_obj_ref(obj: &read_fonts::tables::math::GlyphPart, _: FontData) -> Self {
        GlyphPart {
            glyph_id: obj.glyph_id(),
            start_connector_length: obj.start_connector_length(),
            end_connector_length: obj.end_connector_length(),
            full_advance: obj.full_advance(),
            part_flags: obj.part_flags(),
        }
    }
}

impl FontWrite for GlyphPartFlags {
    fn write_into(&self, writer: &mut TableWriter) {
        writer.write_slice(&self.bits().to_be_bytes())
    }
}

/// [Math Value Record](https://learn.microsoft.com/en-gb/typography/opentype/spec/math#mathvaluerecord)
#[derive(Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct MathValueRecord {
    /// The X or Y value in design units
    pub value: FWord,
    /// Offset to the device table, from the beginning of parent table
    pub device_table: NullableOffsetMarker<DeviceTable>,
}

impl MathValueRecord {
    /// Construct a new `MathValueRecord`
    pub fn new(value: FWord, device_table: Option<DeviceTable>) -> Self {
        Self {
            value,
            device_table: device_table.into(),
        }
    }
}

impl FontWrite for MathValueRecord {
    fn write_into(&self, writer: &mut TableWriter) {
        self.value.write_into(writer);
        self.device_table.write_into(writer);
    }
    fn table_type(&self) -> TableType {
        TableType::Named("MathValueRecord")
    }
}

impl Validate for MathValueRecord {
    fn validate_impl(&self, ctx: &mut ValidationCtx) {
        ctx.in_table("MathValueRecord", |ctx| {
            ctx.in_field("device_table", |ctx| {
                self.device_table.validate_impl(ctx);
            });
        })
    }
}

impl FromObjRef<read_fonts::tables::math::MathValueRecord> for MathValueRecord {
    fn from_obj_ref(
        obj: &read_fonts::tables::math::MathValueRecord,
        offset_data: FontData,
    ) -> Self {
        MathValueRecord {
            value: obj.value(),
            device_table: obj.device_table(offset_data).to_owned_table(),
        }
    }
}
