// THIS FILE IS AUTOGENERATED.
// Any changes to this file will be overwritten.
// For more information about how codegen works, see font-codegen/README.md

#[allow(unused_imports)]
use crate::codegen_prelude::*;

#[derive(Clone, Debug, Default)]
pub struct BasicTable {
    pub simple_count: u16,
    pub simple_records: Vec<SimpleRecord>,
    pub arrays_inner_count: u16,
    pub array_records_count: u32,
    pub array_records: Vec<ContainsArrays>,
}

impl FontWrite for BasicTable {
    fn write_into(&self, writer: &mut TableWriter) {
        self.simple_count.write_into(writer);
        self.simple_records.write_into(writer);
        self.arrays_inner_count.write_into(writer);
        self.array_records_count.write_into(writer);
        self.array_records.write_into(writer);
    }
}

impl Validate for BasicTable {
    fn validate_impl(&self, ctx: &mut ValidationCtx) {
        ctx.in_table("BasicTable", |ctx| {
            ctx.in_field("simple_records", |ctx| {
                if self.simple_records.len() > (u16::MAX as usize) {
                    ctx.report("array excedes max length");
                }
                self.simple_records.validate_impl(ctx);
            });
            ctx.in_field("array_records", |ctx| {
                if self.array_records.len() > (u32::MAX as usize) {
                    ctx.report("array excedes max length");
                }
                self.array_records.validate_impl(ctx);
            });
        })
    }
}

impl<'a> FromObjRef<read_fonts::codegen_test::records::BasicTable<'a>> for BasicTable {
    fn from_obj_ref(obj: &read_fonts::codegen_test::records::BasicTable<'a>, _: FontData) -> Self {
        let offset_data = obj.offset_data();
        BasicTable {
            simple_count: obj.simple_count(),
            simple_records: obj.simple_records().to_owned_obj(offset_data),
            arrays_inner_count: obj.arrays_inner_count(),
            array_records_count: obj.array_records_count(),
            array_records: obj
                .array_records()
                .iter()
                .filter_map(|x| x.map(|x| FromObjRef::from_obj_ref(&x, offset_data)).ok())
                .collect(),
        }
    }
}

impl<'a> FromTableRef<read_fonts::codegen_test::records::BasicTable<'a>> for BasicTable {}

impl<'a> FontRead<'a> for BasicTable {
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        <read_fonts::codegen_test::records::BasicTable as FontRead>::read(data)
            .map(|x| x.to_owned_table())
    }
}

#[derive(Clone, Debug, Default)]
pub struct SimpleRecord {
    pub val1: u16,
    pub va2: u32,
}

impl FontWrite for SimpleRecord {
    fn write_into(&self, writer: &mut TableWriter) {
        self.val1.write_into(writer);
        self.va2.write_into(writer);
    }
}

impl Validate for SimpleRecord {
    fn validate_impl(&self, _ctx: &mut ValidationCtx) {}
}

impl FromObjRef<read_fonts::codegen_test::records::SimpleRecord> for SimpleRecord {
    fn from_obj_ref(obj: &read_fonts::codegen_test::records::SimpleRecord, _: FontData) -> Self {
        SimpleRecord {
            val1: obj.val1(),
            va2: obj.va2(),
        }
    }
}

#[derive(Clone, Debug, Default)]
pub struct ContainsArrays {
    pub scalars: Vec<u16>,
    pub records: Vec<SimpleRecord>,
}

impl FontWrite for ContainsArrays {
    fn write_into(&self, writer: &mut TableWriter) {
        self.scalars.write_into(writer);
        self.records.write_into(writer);
    }
}

impl Validate for ContainsArrays {
    fn validate_impl(&self, ctx: &mut ValidationCtx) {
        ctx.in_table("ContainsArrays", |ctx| {
            ctx.in_field("scalars", |ctx| {
                if self.scalars.len() > (u16::MAX as usize) {
                    ctx.report("array excedes max length");
                }
            });
            ctx.in_field("records", |ctx| {
                if self.records.len() > (u16::MAX as usize) {
                    ctx.report("array excedes max length");
                }
                self.records.validate_impl(ctx);
            });
        })
    }
}

impl FromObjRef<read_fonts::codegen_test::records::ContainsArrays<'_>> for ContainsArrays {
    fn from_obj_ref(
        obj: &read_fonts::codegen_test::records::ContainsArrays,
        offset_data: FontData,
    ) -> Self {
        ContainsArrays {
            scalars: obj.scalars().to_owned_obj(offset_data),
            records: obj.records().to_owned_obj(offset_data),
        }
    }
}

#[derive(Clone, Debug, Default)]
pub struct ContainsOffests {
    pub off_array_count: u16,
    pub array_offset: OffsetMarker<Vec<SimpleRecord>>,
    pub other_offset: OffsetMarker<BasicTable, WIDTH_32>,
}

impl FontWrite for ContainsOffests {
    fn write_into(&self, writer: &mut TableWriter) {
        self.off_array_count.write_into(writer);
        self.array_offset.write_into(writer);
        self.other_offset.write_into(writer);
    }
}

impl Validate for ContainsOffests {
    fn validate_impl(&self, ctx: &mut ValidationCtx) {
        ctx.in_table("ContainsOffests", |ctx| {
            ctx.in_field("array_offset", |ctx| {
                self.array_offset.validate_impl(ctx);
            });
            ctx.in_field("other_offset", |ctx| {
                self.other_offset.validate_impl(ctx);
            });
        })
    }
}

impl FromObjRef<read_fonts::codegen_test::records::ContainsOffests> for ContainsOffests {
    fn from_obj_ref(
        obj: &read_fonts::codegen_test::records::ContainsOffests,
        offset_data: FontData,
    ) -> Self {
        ContainsOffests {
            off_array_count: obj.off_array_count(),
            array_offset: obj.array(offset_data).to_owned_obj(offset_data),
            other_offset: obj.other(offset_data).to_owned_table(),
        }
    }
}
