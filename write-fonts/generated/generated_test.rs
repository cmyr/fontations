// THIS FILE IS AUTOGENERATED.
// Any changes to this file will be overwritten.
// For more information about how codegen works, see font-codegen/README.md

#[allow(unused_imports)]
use crate::codegen_prelude::*;

#[derive(Clone, Debug)]
pub struct KindsOfOffsets {
    /// The major/minor version of the GDEF table
    pub version: MajorMinor,
    /// A normal offset
    pub nonnullable_offset: OffsetMarker<Dummy>,
    /// An offset that is nullable, but always present
    pub nullable_offset: NullableOffsetMarker<Dummy>,
    /// count of the array at array_offset
    pub array_offset_count: u16,
    /// An offset to an array:
    pub array_offset: OffsetMarker<Vec<u16>>,
    /// An offset to an array of records
    pub record_array_offset: OffsetMarker<Vec<Shmecord>>,
    /// A nullable, versioned offset to an array of records
    pub versioned_nullable_record_array_offset: NullableOffsetMarker<Vec<Shmecord>>,
    /// A normal offset that is versioned
    pub versioned_nonnullable_offset: Option<OffsetMarker<Dummy>>,
    /// An offset that is nullable and versioned
    pub versioned_nullable_offset: NullableOffsetMarker<Dummy, WIDTH_32>,
}

impl Default for KindsOfOffsets {
    fn default() -> Self {
        Self {
            version: MajorMinor::VERSION_1_1,
            nonnullable_offset: Default::default(),
            nullable_offset: Default::default(),
            array_offset_count: Default::default(),
            array_offset: Default::default(),
            record_array_offset: Default::default(),
            versioned_nullable_record_array_offset: Default::default(),
            versioned_nonnullable_offset: Default::default(),
            versioned_nullable_offset: Default::default(),
        }
    }
}

impl FontWrite for KindsOfOffsets {
    fn write_into(&self, writer: &mut TableWriter) {
        let version = self.version;
        version.write_into(writer);
        self.nonnullable_offset.write_into(writer);
        self.nullable_offset.write_into(writer);
        self.array_offset_count.write_into(writer);
        self.array_offset.write_into(writer);
        self.record_array_offset.write_into(writer);
        version.compatible(MajorMinor::VERSION_1_1).then(|| {
            self.versioned_nullable_record_array_offset
                .write_into(writer)
        });
        version.compatible(MajorMinor::VERSION_1_1).then(|| {
            self.versioned_nonnullable_offset
                .as_ref()
                .expect("missing versioned field should have failed validation")
                .write_into(writer)
        });
        version
            .compatible(MajorMinor::VERSION_1_1)
            .then(|| self.versioned_nullable_offset.write_into(writer));
    }
}

impl Validate for KindsOfOffsets {
    fn validate_impl(&self, ctx: &mut ValidationCtx) {
        ctx.in_table("KindsOfOffsets", |ctx| {
            let version = self.version;
            ctx.in_field("nonnullable_offset", |ctx| {
                self.nonnullable_offset.validate_impl(ctx);
            });
            ctx.in_field("nullable_offset", |ctx| {
                self.nullable_offset.validate_impl(ctx);
            });
            ctx.in_field("record_array_offset", |ctx| {
                self.record_array_offset.validate_impl(ctx);
            });
            ctx.in_field("versioned_nullable_record_array_offset", |ctx| {
                self.versioned_nullable_record_array_offset
                    .validate_impl(ctx);
            });
            ctx.in_field("versioned_nonnullable_offset", |ctx| {
                if version.compatible(MajorMinor::VERSION_1_1)
                    && self.versioned_nonnullable_offset.is_none()
                {
                    ctx.report(format!("field must be present for version {version}"));
                }
                self.versioned_nonnullable_offset.validate_impl(ctx);
            });
            ctx.in_field("versioned_nullable_offset", |ctx| {
                self.versioned_nullable_offset.validate_impl(ctx);
            });
        })
    }
}

impl<'a> FromObjRef<read_fonts::codegen_test::KindsOfOffsets<'a>> for KindsOfOffsets {
    fn from_obj_ref(obj: &read_fonts::codegen_test::KindsOfOffsets<'a>, _: FontData) -> Self {
        let offset_data = obj.offset_data();
        KindsOfOffsets {
            version: obj.version(),
            nonnullable_offset: obj.nonnullable().to_owned_table(),
            nullable_offset: obj.nullable().to_owned_table(),
            array_offset_count: obj.array_offset_count(),
            array_offset: obj.array().to_owned_obj(offset_data),
            record_array_offset: obj.record_array().to_owned_obj(offset_data),
            versioned_nullable_record_array_offset: obj
                .versioned_nullable_record_array()
                .to_owned_obj(offset_data),
            versioned_nonnullable_offset: obj.versioned_nonnullable().to_owned_table(),
            versioned_nullable_offset: obj.versioned_nullable().to_owned_table(),
        }
    }
}

impl<'a> FromTableRef<read_fonts::codegen_test::KindsOfOffsets<'a>> for KindsOfOffsets {}

impl<'a> FontRead<'a> for KindsOfOffsets {
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        <read_fonts::codegen_test::KindsOfOffsets as FontRead>::read(data)
            .map(|x| x.to_owned_table())
    }
}

#[derive(Clone, Debug, Default)]
pub struct KindsOfArraysOfOffsets {
    /// The number of items in each array
    pub count: u16,
    /// A normal array offset
    pub nonnullable_offsets: Vec<OffsetMarker<Dummy>>,
    /// An offset that is nullable, but always present
    pub nullable_offsets: Vec<NullableOffsetMarker<Dummy>>,
    /// A normal offset that is versioned
    pub versioned_nonnullable_offsets: Option<Vec<OffsetMarker<Dummy>>>,
    /// An offset that is nullable and versioned
    pub versioned_nullable_offsets: Option<Vec<NullableOffsetMarker<Dummy>>>,
}

impl FontWrite for KindsOfArraysOfOffsets {
    #[allow(clippy::unnecessary_cast)]
    fn write_into(&self, writer: &mut TableWriter) {
        let version = MajorMinor::VERSION_1_1 as MajorMinor;
        version.write_into(writer);
        self.count.write_into(writer);
        self.nonnullable_offsets.write_into(writer);
        self.nullable_offsets.write_into(writer);
        version.compatible(MajorMinor::VERSION_1_1).then(|| {
            self.versioned_nonnullable_offsets
                .as_ref()
                .expect("missing versioned field should have failed validation")
                .write_into(writer)
        });
        version.compatible(MajorMinor::VERSION_1_1).then(|| {
            self.versioned_nullable_offsets
                .as_ref()
                .expect("missing versioned field should have failed validation")
                .write_into(writer)
        });
    }
}

impl Validate for KindsOfArraysOfOffsets {
    fn validate_impl(&self, ctx: &mut ValidationCtx) {
        ctx.in_table("KindsOfArraysOfOffsets", |ctx| {
            let version: MajorMinor = MajorMinor::VERSION_1_1;
            ctx.in_field("nonnullable_offsets", |ctx| {
                if self.nonnullable_offsets.len() > (u16::MAX as usize) {
                    ctx.report("array excedes max length");
                }
                self.nonnullable_offsets.validate_impl(ctx);
            });
            ctx.in_field("nullable_offsets", |ctx| {
                if self.nullable_offsets.len() > (u16::MAX as usize) {
                    ctx.report("array excedes max length");
                }
                self.nullable_offsets.validate_impl(ctx);
            });
            ctx.in_field("versioned_nonnullable_offsets", |ctx| {
                if version.compatible(MajorMinor::VERSION_1_1)
                    && self.versioned_nonnullable_offsets.is_none()
                {
                    ctx.report(format!("field must be present for version {version}"));
                }
                if self.versioned_nonnullable_offsets.is_some()
                    && self.versioned_nonnullable_offsets.as_ref().unwrap().len()
                        > (u16::MAX as usize)
                {
                    ctx.report("array excedes max length");
                }
                self.versioned_nonnullable_offsets.validate_impl(ctx);
            });
            ctx.in_field("versioned_nullable_offsets", |ctx| {
                if version.compatible(MajorMinor::VERSION_1_1)
                    && self.versioned_nullable_offsets.is_none()
                {
                    ctx.report(format!("field must be present for version {version}"));
                }
                if self.versioned_nullable_offsets.is_some()
                    && self.versioned_nullable_offsets.as_ref().unwrap().len() > (u16::MAX as usize)
                {
                    ctx.report("array excedes max length");
                }
                self.versioned_nullable_offsets.validate_impl(ctx);
            });
        })
    }
}

impl<'a> FromObjRef<read_fonts::codegen_test::KindsOfArraysOfOffsets<'a>>
    for KindsOfArraysOfOffsets
{
    fn from_obj_ref(
        obj: &read_fonts::codegen_test::KindsOfArraysOfOffsets<'a>,
        _: FontData,
    ) -> Self {
        KindsOfArraysOfOffsets {
            count: obj.count(),
            nonnullable_offsets: obj.nonnullables().map(|x| x.to_owned_table()).collect(),
            nullable_offsets: obj.nullables().map(|x| x.to_owned_table()).collect(),
            versioned_nonnullable_offsets: obj
                .versioned_nonnullables()
                .map(|obj| obj.map(|x| x.to_owned_table()).collect()),
            versioned_nullable_offsets: obj
                .versioned_nullables()
                .map(|obj| obj.map(|x| x.to_owned_table()).collect()),
        }
    }
}

impl<'a> FromTableRef<read_fonts::codegen_test::KindsOfArraysOfOffsets<'a>>
    for KindsOfArraysOfOffsets
{
}

impl<'a> FontRead<'a> for KindsOfArraysOfOffsets {
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        <read_fonts::codegen_test::KindsOfArraysOfOffsets as FontRead>::read(data)
            .map(|x| x.to_owned_table())
    }
}

#[derive(Clone, Debug)]
pub struct KindsOfArrays {
    pub version: u16,
    /// the number of items in each array
    pub count: u16,
    /// an array of scalars
    pub scalars: Vec<u16>,
    /// an array of records
    pub records: Vec<Shmecord>,
    /// a versioned array of scalars
    pub versioned_scalars: Option<Vec<u16>>,
    /// a versioned array of scalars
    pub versioned_records: Option<Vec<Shmecord>>,
}

impl Default for KindsOfArrays {
    fn default() -> Self {
        Self {
            version: 1,
            count: Default::default(),
            scalars: Default::default(),
            records: Default::default(),
            versioned_scalars: Default::default(),
            versioned_records: Default::default(),
        }
    }
}

impl FontWrite for KindsOfArrays {
    fn write_into(&self, writer: &mut TableWriter) {
        let version = self.version;
        version.write_into(writer);
        self.count.write_into(writer);
        self.scalars.write_into(writer);
        self.records.write_into(writer);
        version.compatible(1).then(|| {
            self.versioned_scalars
                .as_ref()
                .expect("missing versioned field should have failed validation")
                .write_into(writer)
        });
        version.compatible(1).then(|| {
            self.versioned_records
                .as_ref()
                .expect("missing versioned field should have failed validation")
                .write_into(writer)
        });
    }
}

impl Validate for KindsOfArrays {
    fn validate_impl(&self, ctx: &mut ValidationCtx) {
        ctx.in_table("KindsOfArrays", |ctx| {
            let version = self.version;
            ctx.in_field("scalars", |ctx| {
                if self.scalars.len() > (u16::MAX as usize) {
                    ctx.report("array excedes max length");
                }
            });
            ctx.in_field("records", |ctx| {
                if self.records.len() > (u16::MAX as usize) {
                    ctx.report("array excedes max length");
                }
                self.records.validate_impl(ctx);
            });
            ctx.in_field("versioned_scalars", |ctx| {
                if version.compatible(1) && self.versioned_scalars.is_none() {
                    ctx.report(format!("field must be present for version {version}"));
                }
                if self.versioned_scalars.is_some()
                    && self.versioned_scalars.as_ref().unwrap().len() > (u16::MAX as usize)
                {
                    ctx.report("array excedes max length");
                }
            });
            ctx.in_field("versioned_records", |ctx| {
                if version.compatible(1) && self.versioned_records.is_none() {
                    ctx.report(format!("field must be present for version {version}"));
                }
                if self.versioned_records.is_some()
                    && self.versioned_records.as_ref().unwrap().len() > (u16::MAX as usize)
                {
                    ctx.report("array excedes max length");
                }
                self.versioned_records.validate_impl(ctx);
            });
        })
    }
}

impl<'a> FromObjRef<read_fonts::codegen_test::KindsOfArrays<'a>> for KindsOfArrays {
    fn from_obj_ref(obj: &read_fonts::codegen_test::KindsOfArrays<'a>, _: FontData) -> Self {
        let offset_data = obj.offset_data();
        KindsOfArrays {
            version: obj.version(),
            count: obj.count(),
            scalars: obj.scalars().to_owned_obj(offset_data),
            records: obj.records().to_owned_obj(offset_data),
            versioned_scalars: obj.versioned_scalars().to_owned_obj(offset_data),
            versioned_records: obj.versioned_records().to_owned_obj(offset_data),
        }
    }
}

impl<'a> FromTableRef<read_fonts::codegen_test::KindsOfArrays<'a>> for KindsOfArrays {}

impl<'a> FontRead<'a> for KindsOfArrays {
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        <read_fonts::codegen_test::KindsOfArrays as FontRead>::read(data)
            .map(|x| x.to_owned_table())
    }
}

#[derive(Clone, Debug, Default)]
pub struct Dummy {
    pub value: u16,
}

impl FontWrite for Dummy {
    fn write_into(&self, writer: &mut TableWriter) {
        self.value.write_into(writer);
    }
}

impl Validate for Dummy {
    fn validate_impl(&self, _ctx: &mut ValidationCtx) {}
}

impl<'a> FromObjRef<read_fonts::codegen_test::Dummy<'a>> for Dummy {
    fn from_obj_ref(obj: &read_fonts::codegen_test::Dummy<'a>, _: FontData) -> Self {
        Dummy { value: obj.value() }
    }
}

impl<'a> FromTableRef<read_fonts::codegen_test::Dummy<'a>> for Dummy {}

impl<'a> FontRead<'a> for Dummy {
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        <read_fonts::codegen_test::Dummy as FontRead>::read(data).map(|x| x.to_owned_table())
    }
}

#[derive(Clone, Debug, Default)]
pub struct Shmecord {
    pub length: u16,
    pub breadth: u32,
}

impl FontWrite for Shmecord {
    fn write_into(&self, writer: &mut TableWriter) {
        self.length.write_into(writer);
        self.breadth.write_into(writer);
    }
}

impl Validate for Shmecord {
    fn validate_impl(&self, _ctx: &mut ValidationCtx) {}
}

impl FromObjRef<read_fonts::codegen_test::Shmecord> for Shmecord {
    fn from_obj_ref(obj: &read_fonts::codegen_test::Shmecord, _: FontData) -> Self {
        Shmecord {
            length: obj.length(),
            breadth: obj.breadth(),
        }
    }
}
