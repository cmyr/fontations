//! Loading, scaling and hinting of glyph outlines.

mod cff;
mod error;
mod glyf;
mod native_hint;

use read_fonts::{types::GlyphId, TableProvider};

pub use error::ScaleError;
pub use native_hint::NativeHinter;

use super::{
    instance::{LocationRef, NormalizedCoord, Size},
    OutlinePen, GLYF_COMPOSITE_RECURSION_LIMIT,
};

/// Source format for an outline glyph.
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum OutlineGlyphFormat {
    /// TrueType outlines sourced from the `glyf` table.
    Glyf,
    /// PostScript outlines sourced from the `CFF` table.
    Cff,
    /// PostScript outlines sourced from the `CFF2` table.
    Cff2,
}

/// Modes for hinting.
///
/// Only the `glyf` source supports all hinting modes.
#[derive(Copy, Clone, PartialEq, Eq, Default, Debug)]
pub enum Hinting {
    /// Hinting is disabled.
    #[default]
    None,
    /// "Full" hinting mode. May generate rough outlines and poor horizontal
    /// spacing.
    Full,
    /// Light hinting mode. This prevents most movement in the horizontal
    /// direction with the exception of a per-font backward compatibility
    /// opt in.
    Light,
    /// Same as light, but with additional support for RGB subpixel rendering.
    LightSubpixel,
    /// Same as light subpixel, but always prevents adjustment in the
    /// horizontal direction. This is the default mode.
    VerticalSubpixel,
}

/// Specifies the source of temporary memory for the outline scaler.
pub enum ScalerMemory<'a> {
    /// The scaler will allocate temporary memory from the heap as needed.
    Auto,
    /// The scaler will allocate temporary memory from the given buffer.
    ///
    /// To compute the required size of this buffer, use the
    /// [`OutlineGlyph::scaler_memory_size`] method.
    User(&'a mut [u8]),
}

/// Information and adjusted metrics generated while scaling a glyph.
#[derive(Copy, Clone, Default, Debug)]
pub struct ScalerMetrics {
    /// True if the underlying glyph contains flags indicating the
    /// presence of overlapping contours or components.
    pub has_overlaps: bool,
    /// If present, an adjusted left side bearing value generated by the
    /// scaler.
    pub adjusted_lsb: Option<f32>,
    /// If present, an adjusted advance width value generated by the
    /// scaler.
    pub adjusted_advance_width: Option<f32>,
}

/// A scalable glyph outline.
#[derive(Clone)]
pub struct OutlineGlyph<'a> {
    kind: OutlineKind<'a>,
}

impl<'a> OutlineGlyph<'a> {
    /// Returns the underlying source format for this outline.
    pub fn format(&self) -> OutlineGlyphFormat {
        match &self.kind {
            OutlineKind::Glyf(..) => OutlineGlyphFormat::Glyf,
            OutlineKind::Cff(cff, ..) => {
                if cff.is_cff2() {
                    OutlineGlyphFormat::Cff2
                } else {
                    OutlineGlyphFormat::Cff
                }
            }
        }
    }

    /// Returns a value indicating if the outline may contain overlapping
    /// contours or components.
    ///
    /// For CFF outlines, returns `None` since this information is unavailable.
    pub fn has_overlaps(&self) -> Option<bool> {
        match &self.kind {
            OutlineKind::Glyf(_, outline) => Some(outline.has_overlaps),
            _ => None,
        }
    }

    /// Returns a value indicating whether the outline has hinting
    /// instructions.
    ///
    /// For CFF outlines, returns `None` since this is unknown prior
    /// to loading the outline.
    pub fn has_hinting(&self) -> Option<bool> {
        match &self.kind {
            OutlineKind::Glyf(_, outline) => Some(outline.has_hinting),
            _ => None,
        }
    }

    /// Returns the size (in bytes) of the temporary memory required to scale
    /// this outline.
    pub fn scaler_memory_size(&self, hinting: Hinting) -> usize {
        match &self.kind {
            OutlineKind::Glyf(_, outline) => outline.required_buffer_size(hinting),
            _ => 0,
        }
    }

    /// Scales the outline glyph and emits the resulting path commands to the
    /// given pen.
    pub fn scale(
        &self,
        size: Size,
        location: impl Into<LocationRef<'a>>,
        mut memory: ScalerMemory,
        pen: &mut impl OutlinePen,
    ) -> Result<ScalerMetrics, ScaleError> {
        let ppem = size.ppem().unwrap_or_default();
        let coords = location.into().coords();
        match &self.kind {
            OutlineKind::Glyf(glyf, outline) => {
                memory.with_glyf_memory(outline, Hinting::None, |buf| {
                    let mem = outline
                        .memory_from_buffer(buf, Hinting::None)
                        .ok_or(ScaleError::InsufficientMemory)?;
                    let scaled_outline = glyf.scale(mem, outline, ppem, coords)?;
                    scaled_outline.to_path(pen)?;
                    Ok(ScalerMetrics {
                        has_overlaps: outline.has_overlaps,
                        ..Default::default()
                    })
                })
            }
            OutlineKind::Cff(cff, glyph_id, subfont_ix) => {
                let subfont = cff.subfont(*subfont_ix, ppem, coords)?;
                cff.outline(&subfont, *glyph_id, coords, false, pen)?;
                Ok(ScalerMetrics::default())
            }
        }
    }
}

#[derive(Clone)]
enum OutlineKind<'a> {
    Glyf(glyf::Outlines<'a>, glyf::Outline<'a>),
    // Third field is subfont index
    Cff(cff::Outlines<'a>, GlyphId, u32),
}

/// Collection of scalable glyph outlines.
#[derive(Clone)]
pub struct OutlineGlyphCollection<'a> {
    kind: OutlineCollectionKind<'a>,
}

impl<'a> OutlineGlyphCollection<'a> {
    /// Creates a new outline collection for the given font.
    pub fn new(font: &impl TableProvider<'a>) -> Self {
        let kind = if let Some(glyf) = glyf::Outlines::new(font) {
            OutlineCollectionKind::Glyf(glyf)
        } else if let Ok(cff) = cff::Outlines::new(font) {
            OutlineCollectionKind::Cff(cff)
        } else {
            OutlineCollectionKind::None
        };
        Self { kind }
    }

    /// Creates a new outline collection for the given font and outline
    /// format.
    ///
    /// Returns `None` if the font does not contain outlines in the requested
    /// format.
    pub fn with_format(font: &impl TableProvider<'a>, format: OutlineGlyphFormat) -> Option<Self> {
        let kind = match format {
            OutlineGlyphFormat::Glyf => OutlineCollectionKind::Glyf(glyf::Outlines::new(font)?),
            OutlineGlyphFormat::Cff => {
                let upem = font.head().ok()?.units_per_em();
                OutlineCollectionKind::Cff(cff::Outlines::from_cff(font.cff().ok()?, 0, upem).ok()?)
            }
            OutlineGlyphFormat::Cff2 => {
                let upem = font.head().ok()?.units_per_em();
                OutlineCollectionKind::Cff(cff::Outlines::from_cff2(font.cff2().ok()?, upem).ok()?)
            }
        };
        Some(Self { kind })
    }

    /// Returns the underlying format of the source outline tables.
    pub fn format(&self) -> Option<OutlineGlyphFormat> {
        match &self.kind {
            OutlineCollectionKind::Glyf(..) => Some(OutlineGlyphFormat::Glyf),
            OutlineCollectionKind::Cff(cff) => cff
                .is_cff2()
                .then_some(OutlineGlyphFormat::Cff2)
                .or(Some(OutlineGlyphFormat::Cff)),
            _ => None,
        }
    }

    /// Returns the outline for the given glyph identifier.
    pub fn get(&self, glyph_id: GlyphId) -> Option<OutlineGlyph<'a>> {
        match &self.kind {
            OutlineCollectionKind::None => None,
            OutlineCollectionKind::Glyf(glyf) => Some(OutlineGlyph {
                kind: OutlineKind::Glyf(glyf.clone(), glyf.outline(glyph_id).ok()?),
            }),
            OutlineCollectionKind::Cff(cff) => Some(OutlineGlyph {
                kind: OutlineKind::Cff(cff.clone(), glyph_id, cff.subfont_index(glyph_id)),
            }),
        }
    }

    /// Returns an iterator over all the outline glyphs in the collection.
    pub fn iter(&self) -> impl Iterator<Item = (GlyphId, OutlineGlyph<'a>)> + 'a + Clone {
        let len = match &self.kind {
            OutlineCollectionKind::Glyf(glyf) => glyf.len(),
            OutlineCollectionKind::Cff(cff) => cff.len(),
            _ => 0,
        } as u16;
        let copy = self.clone();
        (0..len).filter_map(move |gid| {
            let gid = GlyphId::new(gid);
            let glyph = copy.get(gid)?;
            Some((gid, glyph))
        })
    }
}

#[derive(Clone)]
enum OutlineCollectionKind<'a> {
    None,
    Glyf(glyf::Outlines<'a>),
    Cff(cff::Outlines<'a>),
}

const GLYF_SCALER_STACK_BUFFER_SIZE: usize = 4096;

impl<'a> ScalerMemory<'a> {
    /// Invokes the callback with a memory buffer suitable for scaling
    /// the given TrueType outline.
    pub(super) fn with_glyf_memory<R>(
        &mut self,
        outline: &glyf::Outline,
        hinting: Hinting,
        mut f: impl FnMut(&mut [u8]) -> R,
    ) -> R {
        // Wrap in a function and prevent inlining to avoid stack allocation
        // and zeroing if we don't take this code path.
        #[inline(never)]
        fn stack_mem<R>(mut f: impl FnMut(&mut [u8]) -> R) -> R {
            f(&mut [0u8; GLYF_SCALER_STACK_BUFFER_SIZE])
        }
        match self {
            ScalerMemory::User(buf) => f(buf),
            ScalerMemory::Auto => {
                let buf_size = outline.required_buffer_size(hinting);
                if buf_size <= GLYF_SCALER_STACK_BUFFER_SIZE {
                    stack_mem(f)
                } else {
                    f(&mut vec![0u8; buf_size])
                }
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::MetadataProvider;
    use read_fonts::{scaler_test, types::GlyphId, FontRef, TableProvider};

    #[test]
    fn outline_glyph_formats() {
        let font_format_pairs = [
            (font_test_data::VAZIRMATN_VAR, OutlineGlyphFormat::Glyf),
            (
                font_test_data::CANTARELL_VF_TRIMMED,
                OutlineGlyphFormat::Cff2,
            ),
            (
                font_test_data::NOTO_SERIF_DISPLAY_TRIMMED,
                OutlineGlyphFormat::Cff,
            ),
            (font_test_data::COLRV0V1_VARIABLE, OutlineGlyphFormat::Glyf),
        ];
        for (font_data, format) in font_format_pairs {
            assert_eq!(
                FontRef::new(font_data).unwrap().outline_glyphs().format(),
                Some(format)
            );
        }
    }

    #[test]
    fn vazirmatin_var() {
        compare_glyphs(
            font_test_data::VAZIRMATN_VAR,
            font_test_data::VAZIRMATN_VAR_GLYPHS,
        );
    }

    #[test]
    fn cantarell_vf() {
        compare_glyphs(
            font_test_data::CANTARELL_VF_TRIMMED,
            font_test_data::CANTARELL_VF_TRIMMED_GLYPHS,
        );
    }

    #[test]
    fn noto_serif_display() {
        compare_glyphs(
            font_test_data::NOTO_SERIF_DISPLAY_TRIMMED,
            font_test_data::NOTO_SERIF_DISPLAY_TRIMMED_GLYPHS,
        );
    }

    #[test]
    fn overlap_flags() {
        let font = FontRef::new(font_test_data::VAZIRMATN_VAR).unwrap();
        let outlines = font.outline_glyphs();
        let glyph_count = font.maxp().unwrap().num_glyphs();
        // GID 2 is a composite glyph with the overlap bit on a component
        // GID 3 is a simple glyph with the overlap bit on the first flag
        let expected_gids_with_overlap = vec![2, 3];
        assert_eq!(
            expected_gids_with_overlap,
            (0..glyph_count)
                .filter(
                    |gid| outlines.get(GlyphId::new(*gid)).unwrap().has_overlaps() == Some(true)
                )
                .collect::<Vec<_>>()
        );
    }

    fn compare_glyphs(font_data: &[u8], expected_outlines: &str) {
        let font = FontRef::new(font_data).unwrap();
        let expected_outlines = scaler_test::parse_glyph_outlines(expected_outlines);
        let mut path = scaler_test::Path::default();
        for expected_outline in &expected_outlines {
            if expected_outline.size == 0.0 && !expected_outline.coords.is_empty() {
                continue;
            }
            path.elements.clear();
            font.outline_glyphs()
                .get(expected_outline.glyph_id)
                .unwrap()
                .scale(
                    Size::new(expected_outline.size),
                    expected_outline.coords.as_slice(),
                    ScalerMemory::Auto,
                    &mut path,
                )
                .unwrap();
            if path.elements != expected_outline.path {
                panic!(
                    "mismatch in glyph path for id {} (size: {}, coords: {:?}): path: {:?} expected_path: {:?}",
                    expected_outline.glyph_id,
                    expected_outline.size,
                    expected_outline.coords,
                    &path.elements,
                    &expected_outline.path
                );
            }
        }
    }
}
