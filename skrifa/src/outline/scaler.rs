//! Scaler instance state.

use super::{
    cff, glyf, Hinting, LocationRef, NormalizedCoord, Outline, OutlineCollection,
    OutlineCollectionKind, OutlineKind, Pen, ScalerError, Size,
};

/// Information and adjusted metrics generated while scaling a glyph.
#[derive(Copy, Clone, Default, Debug)]
pub struct ScalerMetrics {
    /// True if the underlying glyph contains flags indicating the
    /// presence of overlapping contours or components.
    pub has_overlaps: bool,
    /// If present, an adjusted left side bearing value generated by the
    /// scaler.
    pub adjusted_lsb: Option<f32>,
    /// If present, an adjusted advance width value generated by the
    /// scaler.
    pub adjusted_advance_width: Option<f32>,
}

/// Outline scaling state for a particular font instance.
#[derive(Clone)]
pub struct Scaler {
    size: Size,
    coords: Vec<NormalizedCoord>,
    hinting: Hinting,
    kind: ScalerKind,
}

impl Default for Scaler {
    fn default() -> Self {
        Self {
            size: Size::unscaled(),
            coords: vec![],
            hinting: Hinting::None,
            kind: ScalerKind::None,
        }
    }
}

impl Scaler {
    /// Returns the currently configured size.
    pub fn size(&self) -> Size {
        self.size
    }

    /// Returns the currently configured normalized location in variation space.
    pub fn location(&self) -> LocationRef {
        LocationRef::new(&self.coords)
    }

    /// Returns the currently configured hinting mode.
    pub fn hinting(&self) -> Hinting {
        self.hinting
    }

    /// Resets the scaler state for a new font instance with the given
    /// outline collection and settings.
    pub fn reconfigure(
        &mut self,
        outlines: &OutlineCollection,
        size: Size,
        location: LocationRef,
        hinting: Hinting,
    ) {
        self.size = size;
        self.coords.clear();
        self.coords.extend_from_slice(location.coords());
        self.hinting = hinting;
        // Reuse scaler kind memory if the font contains the same outline format
        let current_kind = core::mem::replace(&mut self.kind, ScalerKind::None);
        match &outlines.kind {
            OutlineCollectionKind::Glyf(_) => {
                self.kind = ScalerKind::Glyf();
            }
            OutlineCollectionKind::Cff(cff) => {
                let mut subfonts = match current_kind {
                    ScalerKind::Cff(subfonts) => subfonts,
                    _ => vec![],
                };
                subfonts.clear();
                let size = size.ppem().unwrap_or_default();
                for i in 0..cff.subfont_count() {
                    subfonts.push(cff.subfont(i, size, &self.coords).ok());
                }
                self.kind = ScalerKind::Cff(subfonts);
            }
            OutlineCollectionKind::None => {}
        }
    }

    pub(super) fn scale(
        &self,
        outline: &Outline,
        memory: Option<&mut [u8]>,
        pen: &mut impl Pen,
    ) -> Result<ScalerMetrics, ScalerError> {
        match (&self.kind, &outline.kind) {
            (ScalerKind::Glyf(..), OutlineKind::Glyf(glyf, outline)) => {
                let scaler = GlyfScaler {
                    outlines: glyf,
                    outline: outline,
                    size: self.size.ppem().unwrap_or_default(),
                    coords: &self.coords,
                    hinting: self.hinting,
                };
                match memory {
                    Some(buf) => {
                        scaler.scale(buf, pen)?;
                    }
                    _ => {
                        let buf_size = outline.required_buffer_size(self.hinting);
                        if buf_size <= GLYF_SCALER_STACK_BUFFER_SIZE {
                            scale_glyf_with_stack_memory(&scaler, pen)?;
                        } else {
                            scaler.scale(&mut vec![0u8; buf_size], pen)?;
                        }
                    }
                }
                Ok(ScalerMetrics {
                    has_overlaps: outline.has_overlaps,
                    ..Default::default()
                })
            }
            (ScalerKind::Cff(subfonts), OutlineKind::Cff(cff, glyph_id, subfont_ix)) => {
                let Some(Some(subfont)) = subfonts.get(*subfont_ix as usize) else {
                    return Err(ScalerError::NoSources);
                };
                cff.outline(
                    subfont,
                    *glyph_id,
                    &self.coords,
                    self.hinting != Hinting::None,
                    pen,
                )?;
                Ok(ScalerMetrics::default())
            }
            _ => Err(ScalerError::NoSources),
        }
    }
}

struct GlyfScaler<'a> {
    outlines: &'a glyf::Outlines<'a>,
    outline: &'a glyf::Outline<'a>,
    size: f32,
    coords: &'a [NormalizedCoord],
    hinting: Hinting,
}

impl<'a> GlyfScaler<'a> {
    fn scale(&self, memory: &mut [u8], pen: &mut impl Pen) -> Result<(), ScalerError> {
        let memory = self
            .outline
            .memory_from_buffer(memory, self.hinting)
            .ok_or(ScalerError::InsufficientMemory)?;
        let outline = self
            .outlines
            .scale(memory, self.outline, self.size, self.coords)?;
        outline.to_path(pen)?;
        Ok(())
    }
}

const GLYF_SCALER_STACK_BUFFER_SIZE: usize = 4096;

// Intentionally prevented from inlining to avoid the stack allocation and
// zeroing when unnecessary
#[inline(never)]
fn scale_glyf_with_stack_memory(
    scaler: &GlyfScaler,
    pen: &mut impl Pen,
) -> Result<(), ScalerError> {
    let mut buf = [0u8; GLYF_SCALER_STACK_BUFFER_SIZE];
    scaler.scale(&mut buf, pen)
}

#[derive(Clone)]
enum ScalerKind {
    None,
    Glyf(),
    Cff(Vec<Option<cff::Subfont>>),
}
