// THIS FILE IS AUTOGENERATED.
// Any changes to this file will be overwritten.
// For more information about how codegen works, see font-codegen/README.md

#[allow(unused_imports)]
use crate::codegen_prelude::*;

/// The [Mathematical Typesetting](https://learn.microsoft.com/en-us/typography/opentype/spec/math) table
#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct MathMarker {}

impl MathMarker {
    pub fn major_version_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + u16::RAW_BYTE_LEN
    }

    pub fn minor_version_byte_range(&self) -> Range<usize> {
        let start = self.major_version_byte_range().end;
        start..start + u16::RAW_BYTE_LEN
    }

    pub fn math_constants_offset_byte_range(&self) -> Range<usize> {
        let start = self.minor_version_byte_range().end;
        start..start + Offset16::RAW_BYTE_LEN
    }

    pub fn math_glyph_info_offset_byte_range(&self) -> Range<usize> {
        let start = self.math_constants_offset_byte_range().end;
        start..start + Offset16::RAW_BYTE_LEN
    }

    pub fn math_variants_offset_byte_range(&self) -> Range<usize> {
        let start = self.math_glyph_info_offset_byte_range().end;
        start..start + Offset16::RAW_BYTE_LEN
    }
}

impl TopLevelTable for Math<'_> {
    /// `MATH`
    const TAG: Tag = Tag::new(b"MATH");
}

impl<'a> FontRead<'a> for Math<'a> {
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        let mut cursor = data.cursor();
        cursor.advance::<u16>();
        cursor.advance::<u16>();
        cursor.advance::<Offset16>();
        cursor.advance::<Offset16>();
        cursor.advance::<Offset16>();
        cursor.finish(MathMarker {})
    }
}

/// The [Mathematical Typesetting](https://learn.microsoft.com/en-us/typography/opentype/spec/math) table
pub type Math<'a> = TableRef<'a, MathMarker>;

#[allow(clippy::needless_lifetimes)]
impl<'a> Math<'a> {
    /// Major version of the MATH table, = 1.
    pub fn major_version(&self) -> u16 {
        let range = self.shape.major_version_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Minor version of MATH table, = 0.
    pub fn minor_version(&self) -> u16 {
        let range = self.shape.minor_version_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Offset to MathConstants table, from beginning of MATH table
    pub fn math_constants_offset(&self) -> Offset16 {
        let range = self.shape.math_constants_offset_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Attempt to resolve [`math_constants_offset`][Self::math_constants_offset].
    pub fn math_constants(&self) -> Result<MathConstants<'a>, ReadError> {
        let data = self.data;
        self.math_constants_offset().resolve(data)
    }

    /// Offset to MathGlyphInfo table, from beginning of MATH table
    pub fn math_glyph_info_offset(&self) -> Offset16 {
        let range = self.shape.math_glyph_info_offset_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Attempt to resolve [`math_glyph_info_offset`][Self::math_glyph_info_offset].
    pub fn math_glyph_info(&self) -> Result<MathGlyphInfo<'a>, ReadError> {
        let data = self.data;
        self.math_glyph_info_offset().resolve(data)
    }

    /// Offset to MathVariants table, from beginning of MATH table
    pub fn math_variants_offset(&self) -> Offset16 {
        let range = self.shape.math_variants_offset_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Attempt to resolve [`math_variants_offset`][Self::math_variants_offset].
    pub fn math_variants(&self) -> Result<MathVariants<'a>, ReadError> {
        let data = self.data;
        self.math_variants_offset().resolve(data)
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeTable<'a> for Math<'a> {
    fn type_name(&self) -> &str {
        "Math"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new("major_version", self.major_version())),
            1usize => Some(Field::new("minor_version", self.minor_version())),
            2usize => Some(Field::new(
                "math_constants_offset",
                FieldType::offset(self.math_constants_offset(), self.math_constants()),
            )),
            3usize => Some(Field::new(
                "math_glyph_info_offset",
                FieldType::offset(self.math_glyph_info_offset(), self.math_glyph_info()),
            )),
            4usize => Some(Field::new(
                "math_variants_offset",
                FieldType::offset(self.math_variants_offset(), self.math_variants()),
            )),
            _ => None,
        }
    }
}

#[cfg(feature = "experimental_traverse")]
#[allow(clippy::needless_lifetimes)]
impl<'a> std::fmt::Debug for Math<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

/// [Math Constants](https://learn.microsoft.com/en-gb/typography/opentype/spec/math#mathconstants-table)
#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct MathConstantsMarker {}

impl MathConstantsMarker {
    pub fn script_percent_scale_down_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + i16::RAW_BYTE_LEN
    }

    pub fn script_script_percent_scale_down_byte_range(&self) -> Range<usize> {
        let start = self.script_percent_scale_down_byte_range().end;
        start..start + i16::RAW_BYTE_LEN
    }

    pub fn delimited_sub_formula_min_height_byte_range(&self) -> Range<usize> {
        let start = self.script_script_percent_scale_down_byte_range().end;
        start..start + UfWord::RAW_BYTE_LEN
    }

    pub fn display_operator_min_height_byte_range(&self) -> Range<usize> {
        let start = self.delimited_sub_formula_min_height_byte_range().end;
        start..start + UfWord::RAW_BYTE_LEN
    }

    pub fn math_leading_byte_range(&self) -> Range<usize> {
        let start = self.display_operator_min_height_byte_range().end;
        start..start + self.math_leading_byte_len
    }

    pub fn axis_height_byte_range(&self) -> Range<usize> {
        let start = self.math_leading_byte_range().end;
        start..start + self.axis_height_byte_len
    }

    pub fn accent_base_height_byte_range(&self) -> Range<usize> {
        let start = self.axis_height_byte_range().end;
        start..start + self.accent_base_height_byte_len
    }

    pub fn flattened_accent_base_height_byte_range(&self) -> Range<usize> {
        let start = self.accent_base_height_byte_range().end;
        start..start + self.flattened_accent_base_height_byte_len
    }

    pub fn subscript_shift_down_byte_range(&self) -> Range<usize> {
        let start = self.flattened_accent_base_height_byte_range().end;
        start..start + self.subscript_shift_down_byte_len
    }

    pub fn subscript_top_max_byte_range(&self) -> Range<usize> {
        let start = self.subscript_shift_down_byte_range().end;
        start..start + self.subscript_top_max_byte_len
    }

    pub fn subscript_baseline_drop_min_byte_range(&self) -> Range<usize> {
        let start = self.subscript_top_max_byte_range().end;
        start..start + self.subscript_baseline_drop_min_byte_len
    }

    pub fn superscript_shift_up_byte_range(&self) -> Range<usize> {
        let start = self.subscript_baseline_drop_min_byte_range().end;
        start..start + self.superscript_shift_up_byte_len
    }

    pub fn superscript_shift_up_cramped_byte_range(&self) -> Range<usize> {
        let start = self.superscript_shift_up_byte_range().end;
        start..start + self.superscript_shift_up_cramped_byte_len
    }

    pub fn superscript_bottom_min_byte_range(&self) -> Range<usize> {
        let start = self.superscript_shift_up_cramped_byte_range().end;
        start..start + self.superscript_bottom_min_byte_len
    }

    pub fn superscript_baseline_drop_max_byte_range(&self) -> Range<usize> {
        let start = self.superscript_bottom_min_byte_range().end;
        start..start + self.superscript_baseline_drop_max_byte_len
    }

    pub fn sub_superscript_gap_min_byte_range(&self) -> Range<usize> {
        let start = self.superscript_baseline_drop_max_byte_range().end;
        start..start + self.sub_superscript_gap_min_byte_len
    }

    pub fn superscript_bottom_max_with_subscript_byte_range(&self) -> Range<usize> {
        let start = self.sub_superscript_gap_min_byte_range().end;
        start..start + self.superscript_bottom_max_with_subscript_byte_len
    }

    pub fn space_after_script_byte_range(&self) -> Range<usize> {
        let start = self.superscript_bottom_max_with_subscript_byte_range().end;
        start..start + self.space_after_script_byte_len
    }

    pub fn upper_limit_gap_min_byte_range(&self) -> Range<usize> {
        let start = self.space_after_script_byte_range().end;
        start..start + self.upper_limit_gap_min_byte_len
    }

    pub fn upper_limit_baseline_rise_min_byte_range(&self) -> Range<usize> {
        let start = self.upper_limit_gap_min_byte_range().end;
        start..start + self.upper_limit_baseline_rise_min_byte_len
    }

    pub fn lower_limit_gap_min_byte_range(&self) -> Range<usize> {
        let start = self.upper_limit_baseline_rise_min_byte_range().end;
        start..start + self.lower_limit_gap_min_byte_len
    }

    pub fn lower_limit_baseline_drop_min_byte_range(&self) -> Range<usize> {
        let start = self.lower_limit_gap_min_byte_range().end;
        start..start + self.lower_limit_baseline_drop_min_byte_len
    }

    pub fn stack_top_shift_up_byte_range(&self) -> Range<usize> {
        let start = self.lower_limit_baseline_drop_min_byte_range().end;
        start..start + self.stack_top_shift_up_byte_len
    }

    pub fn stack_top_display_style_shift_up_byte_range(&self) -> Range<usize> {
        let start = self.stack_top_shift_up_byte_range().end;
        start..start + self.stack_top_display_style_shift_up_byte_len
    }

    pub fn stack_bottom_shift_down_byte_range(&self) -> Range<usize> {
        let start = self.stack_top_display_style_shift_up_byte_range().end;
        start..start + self.stack_bottom_shift_down_byte_len
    }

    pub fn stack_bottom_display_style_shift_down_byte_range(&self) -> Range<usize> {
        let start = self.stack_bottom_shift_down_byte_range().end;
        start..start + self.stack_bottom_display_style_shift_down_byte_len
    }

    pub fn stack_gap_min_byte_range(&self) -> Range<usize> {
        let start = self.stack_bottom_display_style_shift_down_byte_range().end;
        start..start + self.stack_gap_min_byte_len
    }

    pub fn stack_display_style_gap_min_byte_range(&self) -> Range<usize> {
        let start = self.stack_gap_min_byte_range().end;
        start..start + self.stack_display_style_gap_min_byte_len
    }

    pub fn stretch_stack_top_shift_up_byte_range(&self) -> Range<usize> {
        let start = self.stack_display_style_gap_min_byte_range().end;
        start..start + self.stretch_stack_top_shift_up_byte_len
    }

    pub fn stretch_stack_bottom_shift_down_byte_range(&self) -> Range<usize> {
        let start = self.stretch_stack_top_shift_up_byte_range().end;
        start..start + self.stretch_stack_bottom_shift_down_byte_len
    }

    pub fn stretch_stack_gap_above_min_byte_range(&self) -> Range<usize> {
        let start = self.stretch_stack_bottom_shift_down_byte_range().end;
        start..start + self.stretch_stack_gap_above_min_byte_len
    }

    pub fn stretch_stack_gap_below_min_byte_range(&self) -> Range<usize> {
        let start = self.stretch_stack_gap_above_min_byte_range().end;
        start..start + self.stretch_stack_gap_below_min_byte_len
    }

    pub fn fraction_numerator_shift_up_byte_range(&self) -> Range<usize> {
        let start = self.stretch_stack_gap_below_min_byte_range().end;
        start..start + self.fraction_numerator_shift_up_byte_len
    }

    pub fn fraction_numerator_display_style_shift_up_byte_range(&self) -> Range<usize> {
        let start = self.fraction_numerator_shift_up_byte_range().end;
        start..start + self.fraction_numerator_display_style_shift_up_byte_len
    }

    pub fn fraction_denominator_shift_down_byte_range(&self) -> Range<usize> {
        let start = self
            .fraction_numerator_display_style_shift_up_byte_range()
            .end;
        start..start + self.fraction_denominator_shift_down_byte_len
    }

    pub fn fraction_denominator_display_style_shift_down_byte_range(&self) -> Range<usize> {
        let start = self.fraction_denominator_shift_down_byte_range().end;
        start..start + self.fraction_denominator_display_style_shift_down_byte_len
    }

    pub fn fraction_numerator_gap_min_byte_range(&self) -> Range<usize> {
        let start = self
            .fraction_denominator_display_style_shift_down_byte_range()
            .end;
        start..start + self.fraction_numerator_gap_min_byte_len
    }

    pub fn fraction_num_display_style_gap_min_byte_range(&self) -> Range<usize> {
        let start = self.fraction_numerator_gap_min_byte_range().end;
        start..start + self.fraction_num_display_style_gap_min_byte_len
    }

    pub fn fraction_rule_thickness_byte_range(&self) -> Range<usize> {
        let start = self.fraction_num_display_style_gap_min_byte_range().end;
        start..start + self.fraction_rule_thickness_byte_len
    }

    pub fn fraction_denominator_gap_min_byte_range(&self) -> Range<usize> {
        let start = self.fraction_rule_thickness_byte_range().end;
        start..start + self.fraction_denominator_gap_min_byte_len
    }

    pub fn fraction_denom_display_style_gap_min_byte_range(&self) -> Range<usize> {
        let start = self.fraction_denominator_gap_min_byte_range().end;
        start..start + self.fraction_denom_display_style_gap_min_byte_len
    }

    pub fn skewed_fraction_horizontal_gap_byte_range(&self) -> Range<usize> {
        let start = self.fraction_denom_display_style_gap_min_byte_range().end;
        start..start + self.skewed_fraction_horizontal_gap_byte_len
    }

    pub fn skewed_fraction_vertical_gap_byte_range(&self) -> Range<usize> {
        let start = self.skewed_fraction_horizontal_gap_byte_range().end;
        start..start + self.skewed_fraction_vertical_gap_byte_len
    }

    pub fn overbar_vertical_gap_byte_range(&self) -> Range<usize> {
        let start = self.skewed_fraction_vertical_gap_byte_range().end;
        start..start + self.overbar_vertical_gap_byte_len
    }

    pub fn overbar_rule_thickness_byte_range(&self) -> Range<usize> {
        let start = self.overbar_vertical_gap_byte_range().end;
        start..start + self.overbar_rule_thickness_byte_len
    }

    pub fn overbar_extra_ascender_byte_range(&self) -> Range<usize> {
        let start = self.overbar_rule_thickness_byte_range().end;
        start..start + self.overbar_extra_ascender_byte_len
    }

    pub fn underbar_vertical_gap_byte_range(&self) -> Range<usize> {
        let start = self.overbar_extra_ascender_byte_range().end;
        start..start + self.underbar_vertical_gap_byte_len
    }

    pub fn underbar_rule_thickness_byte_range(&self) -> Range<usize> {
        let start = self.underbar_vertical_gap_byte_range().end;
        start..start + self.underbar_rule_thickness_byte_len
    }

    pub fn underbar_extra_descender_byte_range(&self) -> Range<usize> {
        let start = self.underbar_rule_thickness_byte_range().end;
        start..start + self.underbar_extra_descender_byte_len
    }

    pub fn radical_vertical_gap_byte_range(&self) -> Range<usize> {
        let start = self.underbar_extra_descender_byte_range().end;
        start..start + self.radical_vertical_gap_byte_len
    }

    pub fn radical_display_style_vertical_gap_byte_range(&self) -> Range<usize> {
        let start = self.radical_vertical_gap_byte_range().end;
        start..start + self.radical_display_style_vertical_gap_byte_len
    }

    pub fn radical_rule_thickness_byte_range(&self) -> Range<usize> {
        let start = self.radical_display_style_vertical_gap_byte_range().end;
        start..start + self.radical_rule_thickness_byte_len
    }

    pub fn radical_extra_ascender_byte_range(&self) -> Range<usize> {
        let start = self.radical_rule_thickness_byte_range().end;
        start..start + self.radical_extra_ascender_byte_len
    }

    pub fn radical_kern_before_degree_byte_range(&self) -> Range<usize> {
        let start = self.radical_extra_ascender_byte_range().end;
        start..start + self.radical_kern_before_degree_byte_len
    }

    pub fn radical_kern_after_degree_byte_range(&self) -> Range<usize> {
        let start = self.radical_kern_before_degree_byte_range().end;
        start..start + self.radical_kern_after_degree_byte_len
    }

    pub fn radical_degree_bottom_raise_percent_byte_range(&self) -> Range<usize> {
        let start = self.radical_kern_after_degree_byte_range().end;
        start..start + i16::RAW_BYTE_LEN
    }
}

impl<'a> FontRead<'a> for MathConstants<'a> {
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        let mut cursor = data.cursor();
        cursor.advance::<i16>();
        cursor.advance::<i16>();
        cursor.advance::<UfWord>();
        cursor.advance::<UfWord>();
        cursor.advance::<MathValueRecord>();
        cursor.advance::<MathValueRecord>();
        cursor.advance::<MathValueRecord>();
        cursor.advance::<MathValueRecord>();
        cursor.advance::<MathValueRecord>();
        cursor.advance::<MathValueRecord>();
        cursor.advance::<MathValueRecord>();
        cursor.advance::<MathValueRecord>();
        cursor.advance::<MathValueRecord>();
        cursor.advance::<MathValueRecord>();
        cursor.advance::<MathValueRecord>();
        cursor.advance::<MathValueRecord>();
        cursor.advance::<MathValueRecord>();
        cursor.advance::<MathValueRecord>();
        cursor.advance::<MathValueRecord>();
        cursor.advance::<MathValueRecord>();
        cursor.advance::<MathValueRecord>();
        cursor.advance::<MathValueRecord>();
        cursor.advance::<MathValueRecord>();
        cursor.advance::<MathValueRecord>();
        cursor.advance::<MathValueRecord>();
        cursor.advance::<MathValueRecord>();
        cursor.advance::<MathValueRecord>();
        cursor.advance::<MathValueRecord>();
        cursor.advance::<MathValueRecord>();
        cursor.advance::<MathValueRecord>();
        cursor.advance::<MathValueRecord>();
        cursor.advance::<MathValueRecord>();
        cursor.advance::<MathValueRecord>();
        cursor.advance::<MathValueRecord>();
        cursor.advance::<MathValueRecord>();
        cursor.advance::<MathValueRecord>();
        cursor.advance::<MathValueRecord>();
        cursor.advance::<MathValueRecord>();
        cursor.advance::<MathValueRecord>();
        cursor.advance::<MathValueRecord>();
        cursor.advance::<MathValueRecord>();
        cursor.advance::<MathValueRecord>();
        cursor.advance::<MathValueRecord>();
        cursor.advance::<MathValueRecord>();
        cursor.advance::<MathValueRecord>();
        cursor.advance::<MathValueRecord>();
        cursor.advance::<MathValueRecord>();
        cursor.advance::<MathValueRecord>();
        cursor.advance::<MathValueRecord>();
        cursor.advance::<MathValueRecord>();
        cursor.advance::<MathValueRecord>();
        cursor.advance::<MathValueRecord>();
        cursor.advance::<MathValueRecord>();
        cursor.advance::<MathValueRecord>();
        cursor.advance::<MathValueRecord>();
        cursor.advance::<i16>();
        cursor.finish(MathConstantsMarker {})
    }
}

/// [Math Constants](https://learn.microsoft.com/en-gb/typography/opentype/spec/math#mathconstants-table)
pub type MathConstants<'a> = TableRef<'a, MathConstantsMarker>;

#[allow(clippy::needless_lifetimes)]
impl<'a> MathConstants<'a> {
    /// Percentage of scaling down for level 1 superscripts and subscripts
    pub fn script_percent_scale_down(&self) -> i16 {
        let range = self.shape.script_percent_scale_down_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Percentage of scaling down for level 2 (scriptScript) superscripts and subscripts
    pub fn script_script_percent_scale_down(&self) -> i16 {
        let range = self.shape.script_script_percent_scale_down_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Minimum height required for a delimited expression (contained within parentheses, etc.) to be treated as a sub-formula
    pub fn delimited_sub_formula_min_height(&self) -> UfWord {
        let range = self.shape.delimited_sub_formula_min_height_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Minimum height of n-ary operators (such as integral and summation) for formulas in display mode
    pub fn display_operator_min_height(&self) -> UfWord {
        let range = self.shape.display_operator_min_height_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// White space to be left between math formulas to ensure proper line spacing
    pub fn math_leading(&self) -> MathValueRecord {
        let range = self.shape.math_leading_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Axis height of the font
    pub fn axis_height(&self) -> MathValueRecord {
        let range = self.shape.axis_height_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Maximum height of accent base that does not require raising the accents
    pub fn accent_base_height(&self) -> MathValueRecord {
        let range = self.shape.accent_base_height_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Maximum (ink) height of accent base that does not require flattening the accent
    pub fn flattened_accent_base_height(&self) -> MathValueRecord {
        let range = self.shape.flattened_accent_base_height_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// The standard shift down applied to subscript elements
    pub fn subscript_shift_down(&self) -> MathValueRecord {
        let range = self.shape.subscript_shift_down_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Maximum allowed height of the (ink) top of subscripts that does not require moving subscripts further down
    pub fn subscript_top_max(&self) -> MathValueRecord {
        let range = self.shape.subscript_top_max_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Minimum allowed drop of the baseline of subscripts relative to the (ink) bottom of the base
    pub fn subscript_baseline_drop_min(&self) -> MathValueRecord {
        let range = self.shape.subscript_baseline_drop_min_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Standard shift up applied to superscript elements
    pub fn superscript_shift_up(&self) -> MathValueRecord {
        let range = self.shape.superscript_shift_up_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Standard shift of superscripts relative to the base, in cramped style
    pub fn superscript_shift_up_cramped(&self) -> MathValueRecord {
        let range = self.shape.superscript_shift_up_cramped_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Minimum allowed height of the (ink) bottom of superscripts that does not require moving subscripts further up
    pub fn superscript_bottom_min(&self) -> MathValueRecord {
        let range = self.shape.superscript_bottom_min_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Maximum allowed drop of the baseline of superscripts relative to the (ink) top of the base
    pub fn superscript_baseline_drop_max(&self) -> MathValueRecord {
        let range = self.shape.superscript_baseline_drop_max_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Minimum gap between the superscript and subscript ink
    pub fn sub_superscript_gap_min(&self) -> MathValueRecord {
        let range = self.shape.sub_superscript_gap_min_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// The maximum level to which the (ink) bottom of superscript can be pushed to increase the gap between superscript and subscript, before subscript starts being moved down
    pub fn superscript_bottom_max_with_subscript(&self) -> MathValueRecord {
        let range = self
            .shape
            .superscript_bottom_max_with_subscript_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Extra white space to be added after each subscript and superscript that occurs after a baseline element, and before each subscript and superscript that occurs before a baseline element
    pub fn space_after_script(&self) -> MathValueRecord {
        let range = self.shape.space_after_script_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Minimum gap between the (ink) bottom of the upper limit, and the (ink) top of the base operator
    pub fn upper_limit_gap_min(&self) -> MathValueRecord {
        let range = self.shape.upper_limit_gap_min_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Minimum distance between baseline of upper limit and (ink) top of the base operator
    pub fn upper_limit_baseline_rise_min(&self) -> MathValueRecord {
        let range = self.shape.upper_limit_baseline_rise_min_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Minimum gap between (ink) top of the lower limit, and (ink) bottom of the base operator
    pub fn lower_limit_gap_min(&self) -> MathValueRecord {
        let range = self.shape.lower_limit_gap_min_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Minimum distance between baseline of the lower limit and (ink) bottom of the base operator
    pub fn lower_limit_baseline_drop_min(&self) -> MathValueRecord {
        let range = self.shape.lower_limit_baseline_drop_min_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Standard shift up applied to the top element of a stack
    pub fn stack_top_shift_up(&self) -> MathValueRecord {
        let range = self.shape.stack_top_shift_up_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Standard shift up applied to the top element of a stack in display style
    pub fn stack_top_display_style_shift_up(&self) -> MathValueRecord {
        let range = self.shape.stack_top_display_style_shift_up_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Standard shift down applied to the bottom element of a stack
    pub fn stack_bottom_shift_down(&self) -> MathValueRecord {
        let range = self.shape.stack_bottom_shift_down_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Standard shift down applied to the bottom element of a stack in display style
    pub fn stack_bottom_display_style_shift_down(&self) -> MathValueRecord {
        let range = self
            .shape
            .stack_bottom_display_style_shift_down_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Minimum gap between (ink) bottom of the top element of a stack, and the (ink) top of the bottom element
    pub fn stack_gap_min(&self) -> MathValueRecord {
        let range = self.shape.stack_gap_min_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Minimum gap between (ink) bottom of the top element of a stack, and the (ink) top of the bottom element in display style
    pub fn stack_display_style_gap_min(&self) -> MathValueRecord {
        let range = self.shape.stack_display_style_gap_min_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Standard shift up applied to the top element of the stretch stack.
    pub fn stretch_stack_top_shift_up(&self) -> MathValueRecord {
        let range = self.shape.stretch_stack_top_shift_up_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Standard shift down applied to the bottom element of the stretch stack.
    pub fn stretch_stack_bottom_shift_down(&self) -> MathValueRecord {
        let range = self.shape.stretch_stack_bottom_shift_down_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Minimum gap between the ink of the stretched element, and the (ink) bottom of the element above
    pub fn stretch_stack_gap_above_min(&self) -> MathValueRecord {
        let range = self.shape.stretch_stack_gap_above_min_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Minimum gap between the ink of the stretched element, and the (ink) top of the element below
    pub fn stretch_stack_gap_below_min(&self) -> MathValueRecord {
        let range = self.shape.stretch_stack_gap_below_min_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Standard shift up applied to the numerator
    pub fn fraction_numerator_shift_up(&self) -> MathValueRecord {
        let range = self.shape.fraction_numerator_shift_up_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Standard shift up applied to the numerator in display style
    pub fn fraction_numerator_display_style_shift_up(&self) -> MathValueRecord {
        let range = self
            .shape
            .fraction_numerator_display_style_shift_up_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Standard shift down applied to the denominator
    pub fn fraction_denominator_shift_down(&self) -> MathValueRecord {
        let range = self.shape.fraction_denominator_shift_down_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Standard shift down applied to the denominator in display style
    pub fn fraction_denominator_display_style_shift_down(&self) -> MathValueRecord {
        let range = self
            .shape
            .fraction_denominator_display_style_shift_down_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Minimum tolerated gap between the (ink) bottom of the numerator and the ink of the fraction bar
    pub fn fraction_numerator_gap_min(&self) -> MathValueRecord {
        let range = self.shape.fraction_numerator_gap_min_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Minimum tolerated gap between the (ink) bottom of the numerator and the ink of the fraction bar in display style
    pub fn fraction_num_display_style_gap_min(&self) -> MathValueRecord {
        let range = self.shape.fraction_num_display_style_gap_min_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Thickness of the fraction bar
    pub fn fraction_rule_thickness(&self) -> MathValueRecord {
        let range = self.shape.fraction_rule_thickness_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Minimum tolerated gap between the (ink) top of the denominator and the ink of the fraction bar
    pub fn fraction_denominator_gap_min(&self) -> MathValueRecord {
        let range = self.shape.fraction_denominator_gap_min_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Minimum tolerated gap between the (ink) top of the denominator and the ink of the fraction bar in display style
    pub fn fraction_denom_display_style_gap_min(&self) -> MathValueRecord {
        let range = self.shape.fraction_denom_display_style_gap_min_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Horizontal distance between the top and bottom elements of a skewed fraction
    pub fn skewed_fraction_horizontal_gap(&self) -> MathValueRecord {
        let range = self.shape.skewed_fraction_horizontal_gap_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Vertical distance between the ink of the top and bottom elements of a skewed fraction
    pub fn skewed_fraction_vertical_gap(&self) -> MathValueRecord {
        let range = self.shape.skewed_fraction_vertical_gap_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Distance between the overbar and the (ink) top of the base
    pub fn overbar_vertical_gap(&self) -> MathValueRecord {
        let range = self.shape.overbar_vertical_gap_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Thickness of overbar
    pub fn overbar_rule_thickness(&self) -> MathValueRecord {
        let range = self.shape.overbar_rule_thickness_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Extra white space reserved above the overbar
    pub fn overbar_extra_ascender(&self) -> MathValueRecord {
        let range = self.shape.overbar_extra_ascender_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Distance between underbar and (ink) bottom of the base
    pub fn underbar_vertical_gap(&self) -> MathValueRecord {
        let range = self.shape.underbar_vertical_gap_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Thickness of underbar
    pub fn underbar_rule_thickness(&self) -> MathValueRecord {
        let range = self.shape.underbar_rule_thickness_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Extra white space reserved below the underbar
    pub fn underbar_extra_descender(&self) -> MathValueRecord {
        let range = self.shape.underbar_extra_descender_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Space between the (ink) top of the expression and the bar over it
    pub fn radical_vertical_gap(&self) -> MathValueRecord {
        let range = self.shape.radical_vertical_gap_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Space between the (ink) top of the expression and the bar over it
    pub fn radical_display_style_vertical_gap(&self) -> MathValueRecord {
        let range = self.shape.radical_display_style_vertical_gap_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Thickness of the radical rule
    pub fn radical_rule_thickness(&self) -> MathValueRecord {
        let range = self.shape.radical_rule_thickness_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Extra white space reserved above the radical
    pub fn radical_extra_ascender(&self) -> MathValueRecord {
        let range = self.shape.radical_extra_ascender_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Extra horizontal kern before the degree of a radical, if such is present
    pub fn radical_kern_before_degree(&self) -> MathValueRecord {
        let range = self.shape.radical_kern_before_degree_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Negative kern after the degree of a radical, if such is present
    pub fn radical_kern_after_degree(&self) -> MathValueRecord {
        let range = self.shape.radical_kern_after_degree_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Height of the bottom of the radical degree, if such is present, in proportion to the height (ascender + descender) of the radical sign
    pub fn radical_degree_bottom_raise_percent(&self) -> i16 {
        let range = self.shape.radical_degree_bottom_raise_percent_byte_range();
        self.data.read_at(range.start).unwrap()
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeTable<'a> for MathConstants<'a> {
    fn type_name(&self) -> &str {
        "MathConstants"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new(
                "script_percent_scale_down",
                self.script_percent_scale_down(),
            )),
            1usize => Some(Field::new(
                "script_script_percent_scale_down",
                self.script_script_percent_scale_down(),
            )),
            2usize => Some(Field::new(
                "delimited_sub_formula_min_height",
                self.delimited_sub_formula_min_height(),
            )),
            3usize => Some(Field::new(
                "display_operator_min_height",
                self.display_operator_min_height(),
            )),
            4usize => Some(compile_error!(concat!(
                "another weird type: ",
                "math_leading"
            ))),
            5usize => Some(compile_error!(concat!(
                "another weird type: ",
                "axis_height"
            ))),
            6usize => Some(compile_error!(concat!(
                "another weird type: ",
                "accent_base_height"
            ))),
            7usize => Some(compile_error!(concat!(
                "another weird type: ",
                "flattened_accent_base_height"
            ))),
            8usize => Some(compile_error!(concat!(
                "another weird type: ",
                "subscript_shift_down"
            ))),
            9usize => Some(compile_error!(concat!(
                "another weird type: ",
                "subscript_top_max"
            ))),
            10usize => Some(compile_error!(concat!(
                "another weird type: ",
                "subscript_baseline_drop_min"
            ))),
            11usize => Some(compile_error!(concat!(
                "another weird type: ",
                "superscript_shift_up"
            ))),
            12usize => Some(compile_error!(concat!(
                "another weird type: ",
                "superscript_shift_up_cramped"
            ))),
            13usize => Some(compile_error!(concat!(
                "another weird type: ",
                "superscript_bottom_min"
            ))),
            14usize => Some(compile_error!(concat!(
                "another weird type: ",
                "superscript_baseline_drop_max"
            ))),
            15usize => Some(compile_error!(concat!(
                "another weird type: ",
                "sub_superscript_gap_min"
            ))),
            16usize => Some(compile_error!(concat!(
                "another weird type: ",
                "superscript_bottom_max_with_subscript"
            ))),
            17usize => Some(compile_error!(concat!(
                "another weird type: ",
                "space_after_script"
            ))),
            18usize => Some(compile_error!(concat!(
                "another weird type: ",
                "upper_limit_gap_min"
            ))),
            19usize => Some(compile_error!(concat!(
                "another weird type: ",
                "upper_limit_baseline_rise_min"
            ))),
            20usize => Some(compile_error!(concat!(
                "another weird type: ",
                "lower_limit_gap_min"
            ))),
            21usize => Some(compile_error!(concat!(
                "another weird type: ",
                "lower_limit_baseline_drop_min"
            ))),
            22usize => Some(compile_error!(concat!(
                "another weird type: ",
                "stack_top_shift_up"
            ))),
            23usize => Some(compile_error!(concat!(
                "another weird type: ",
                "stack_top_display_style_shift_up"
            ))),
            24usize => Some(compile_error!(concat!(
                "another weird type: ",
                "stack_bottom_shift_down"
            ))),
            25usize => Some(compile_error!(concat!(
                "another weird type: ",
                "stack_bottom_display_style_shift_down"
            ))),
            26usize => Some(compile_error!(concat!(
                "another weird type: ",
                "stack_gap_min"
            ))),
            27usize => Some(compile_error!(concat!(
                "another weird type: ",
                "stack_display_style_gap_min"
            ))),
            28usize => Some(compile_error!(concat!(
                "another weird type: ",
                "stretch_stack_top_shift_up"
            ))),
            29usize => Some(compile_error!(concat!(
                "another weird type: ",
                "stretch_stack_bottom_shift_down"
            ))),
            30usize => Some(compile_error!(concat!(
                "another weird type: ",
                "stretch_stack_gap_above_min"
            ))),
            31usize => Some(compile_error!(concat!(
                "another weird type: ",
                "stretch_stack_gap_below_min"
            ))),
            32usize => Some(compile_error!(concat!(
                "another weird type: ",
                "fraction_numerator_shift_up"
            ))),
            33usize => Some(compile_error!(concat!(
                "another weird type: ",
                "fraction_numerator_display_style_shift_up"
            ))),
            34usize => Some(compile_error!(concat!(
                "another weird type: ",
                "fraction_denominator_shift_down"
            ))),
            35usize => Some(compile_error!(concat!(
                "another weird type: ",
                "fraction_denominator_display_style_shift_down"
            ))),
            36usize => Some(compile_error!(concat!(
                "another weird type: ",
                "fraction_numerator_gap_min"
            ))),
            37usize => Some(compile_error!(concat!(
                "another weird type: ",
                "fraction_num_display_style_gap_min"
            ))),
            38usize => Some(compile_error!(concat!(
                "another weird type: ",
                "fraction_rule_thickness"
            ))),
            39usize => Some(compile_error!(concat!(
                "another weird type: ",
                "fraction_denominator_gap_min"
            ))),
            40usize => Some(compile_error!(concat!(
                "another weird type: ",
                "fraction_denom_display_style_gap_min"
            ))),
            41usize => Some(compile_error!(concat!(
                "another weird type: ",
                "skewed_fraction_horizontal_gap"
            ))),
            42usize => Some(compile_error!(concat!(
                "another weird type: ",
                "skewed_fraction_vertical_gap"
            ))),
            43usize => Some(compile_error!(concat!(
                "another weird type: ",
                "overbar_vertical_gap"
            ))),
            44usize => Some(compile_error!(concat!(
                "another weird type: ",
                "overbar_rule_thickness"
            ))),
            45usize => Some(compile_error!(concat!(
                "another weird type: ",
                "overbar_extra_ascender"
            ))),
            46usize => Some(compile_error!(concat!(
                "another weird type: ",
                "underbar_vertical_gap"
            ))),
            47usize => Some(compile_error!(concat!(
                "another weird type: ",
                "underbar_rule_thickness"
            ))),
            48usize => Some(compile_error!(concat!(
                "another weird type: ",
                "underbar_extra_descender"
            ))),
            49usize => Some(compile_error!(concat!(
                "another weird type: ",
                "radical_vertical_gap"
            ))),
            50usize => Some(compile_error!(concat!(
                "another weird type: ",
                "radical_display_style_vertical_gap"
            ))),
            51usize => Some(compile_error!(concat!(
                "another weird type: ",
                "radical_rule_thickness"
            ))),
            52usize => Some(compile_error!(concat!(
                "another weird type: ",
                "radical_extra_ascender"
            ))),
            53usize => Some(compile_error!(concat!(
                "another weird type: ",
                "radical_kern_before_degree"
            ))),
            54usize => Some(compile_error!(concat!(
                "another weird type: ",
                "radical_kern_after_degree"
            ))),
            55usize => Some(Field::new(
                "radical_degree_bottom_raise_percent",
                self.radical_degree_bottom_raise_percent(),
            )),
            _ => None,
        }
    }
}

#[cfg(feature = "experimental_traverse")]
#[allow(clippy::needless_lifetimes)]
impl<'a> std::fmt::Debug for MathConstants<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

/// [MathGlyphInfo](https://learn.microsoft.com/en-gb/typography/opentype/spec/math#mathglyphinfo-table)
#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct MathGlyphInfoMarker {}

impl MathGlyphInfoMarker {
    pub fn math_italics_correction_info_offset_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + Offset16::RAW_BYTE_LEN
    }

    pub fn math_top_accent_attachment_offset_byte_range(&self) -> Range<usize> {
        let start = self.math_italics_correction_info_offset_byte_range().end;
        start..start + Offset16::RAW_BYTE_LEN
    }

    pub fn extended_shape_coverage_offset_byte_range(&self) -> Range<usize> {
        let start = self.math_top_accent_attachment_offset_byte_range().end;
        start..start + Offset16::RAW_BYTE_LEN
    }

    pub fn math_kern_info_offset_byte_range(&self) -> Range<usize> {
        let start = self.extended_shape_coverage_offset_byte_range().end;
        start..start + Offset16::RAW_BYTE_LEN
    }
}

impl<'a> FontRead<'a> for MathGlyphInfo<'a> {
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        let mut cursor = data.cursor();
        cursor.advance::<Offset16>();
        cursor.advance::<Offset16>();
        cursor.advance::<Offset16>();
        cursor.advance::<Offset16>();
        cursor.finish(MathGlyphInfoMarker {})
    }
}

/// [MathGlyphInfo](https://learn.microsoft.com/en-gb/typography/opentype/spec/math#mathglyphinfo-table)
pub type MathGlyphInfo<'a> = TableRef<'a, MathGlyphInfoMarker>;

#[allow(clippy::needless_lifetimes)]
impl<'a> MathGlyphInfo<'a> {
    /// Offset to MathItalicsCorrectionInfo table, from the beginning of the MathGlyphInfo table
    pub fn math_italics_correction_info_offset(&self) -> Offset16 {
        let range = self.shape.math_italics_correction_info_offset_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Attempt to resolve [`math_italics_correction_info_offset`][Self::math_italics_correction_info_offset].
    pub fn math_italics_correction_info(&self) -> Result<MathItalicsCorrectionInfo<'a>, ReadError> {
        let data = self.data;
        self.math_italics_correction_info_offset().resolve(data)
    }

    /// Offset to MathTopAccentAttachment table, from the beginning of the MathGlyphInfo table
    pub fn math_top_accent_attachment_offset(&self) -> Offset16 {
        let range = self.shape.math_top_accent_attachment_offset_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Attempt to resolve [`math_top_accent_attachment_offset`][Self::math_top_accent_attachment_offset].
    pub fn math_top_accent_attachment(&self) -> Result<MathTopAccentAttachment<'a>, ReadError> {
        let data = self.data;
        self.math_top_accent_attachment_offset().resolve(data)
    }

    /// Offset to ExtendedShapes coverage table, from the beginning of the MathGlyphInfo table
    pub fn extended_shape_coverage_offset(&self) -> Nullable<Offset16> {
        let range = self.shape.extended_shape_coverage_offset_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Attempt to resolve [`extended_shape_coverage_offset`][Self::extended_shape_coverage_offset].
    pub fn extended_shape_coverage(&self) -> Option<Result<CoverageTable<'a>, ReadError>> {
        let data = self.data;
        self.extended_shape_coverage_offset().resolve(data)
    }

    /// Offset to MathKernInfo table, from the beginning of the MathGlyphInfo table
    pub fn math_kern_info_offset(&self) -> Offset16 {
        let range = self.shape.math_kern_info_offset_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Attempt to resolve [`math_kern_info_offset`][Self::math_kern_info_offset].
    pub fn math_kern_info(&self) -> Result<MathKernInfo<'a>, ReadError> {
        let data = self.data;
        self.math_kern_info_offset().resolve(data)
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeTable<'a> for MathGlyphInfo<'a> {
    fn type_name(&self) -> &str {
        "MathGlyphInfo"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new(
                "math_italics_correction_info_offset",
                FieldType::offset(
                    self.math_italics_correction_info_offset(),
                    self.math_italics_correction_info(),
                ),
            )),
            1usize => Some(Field::new(
                "math_top_accent_attachment_offset",
                FieldType::offset(
                    self.math_top_accent_attachment_offset(),
                    self.math_top_accent_attachment(),
                ),
            )),
            2usize => Some(Field::new(
                "extended_shape_coverage_offset",
                FieldType::offset(
                    self.extended_shape_coverage_offset(),
                    self.extended_shape_coverage(),
                ),
            )),
            3usize => Some(Field::new(
                "math_kern_info_offset",
                FieldType::offset(self.math_kern_info_offset(), self.math_kern_info()),
            )),
            _ => None,
        }
    }
}

#[cfg(feature = "experimental_traverse")]
#[allow(clippy::needless_lifetimes)]
impl<'a> std::fmt::Debug for MathGlyphInfo<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

/// [MathItalicsCorrectionInfo](https://learn.microsoft.com/en-gb/typography/opentype/spec/math#mathitalicscorrectioninfo-table)
#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct MathItalicsCorrectionInfoMarker {
    italics_correction_byte_len: usize,
}

impl MathItalicsCorrectionInfoMarker {
    pub fn coverage_offset_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + Offset16::RAW_BYTE_LEN
    }

    pub fn italic_correction_count_byte_range(&self) -> Range<usize> {
        let start = self.coverage_offset_byte_range().end;
        start..start + u16::RAW_BYTE_LEN
    }

    pub fn italics_correction_byte_range(&self) -> Range<usize> {
        let start = self.italic_correction_count_byte_range().end;
        start..start + self.italics_correction_byte_len
    }
}

impl<'a> FontRead<'a> for MathItalicsCorrectionInfo<'a> {
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        let mut cursor = data.cursor();
        cursor.advance::<Offset16>();
        let italic_correction_count: u16 = cursor.read()?;
        let italics_correction_byte_len = (italic_correction_count as usize)
            .checked_mul(MathValueRecord::RAW_BYTE_LEN)
            .ok_or(ReadError::OutOfBounds)?;
        cursor.advance_by(italics_correction_byte_len);
        cursor.finish(MathItalicsCorrectionInfoMarker {
            italics_correction_byte_len,
        })
    }
}

/// [MathItalicsCorrectionInfo](https://learn.microsoft.com/en-gb/typography/opentype/spec/math#mathitalicscorrectioninfo-table)
pub type MathItalicsCorrectionInfo<'a> = TableRef<'a, MathItalicsCorrectionInfoMarker>;

#[allow(clippy::needless_lifetimes)]
impl<'a> MathItalicsCorrectionInfo<'a> {
    /// Offset to Coverage table, from the beginning of MathItalicsCorrectionInfo table
    pub fn coverage_offset(&self) -> Offset16 {
        let range = self.shape.coverage_offset_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Attempt to resolve [`coverage_offset`][Self::coverage_offset].
    pub fn coverage(&self) -> Result<CoverageTable<'a>, ReadError> {
        let data = self.data;
        self.coverage_offset().resolve(data)
    }

    /// Number of italics correction values
    pub fn italic_correction_count(&self) -> u16 {
        let range = self.shape.italic_correction_count_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Array of MathValueRecords defining italics correction values for each covered glyph
    pub fn italics_correction(&self) -> &'a [MathValueRecord] {
        let range = self.shape.italics_correction_byte_range();
        self.data.read_array(range).unwrap()
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeTable<'a> for MathItalicsCorrectionInfo<'a> {
    fn type_name(&self) -> &str {
        "MathItalicsCorrectionInfo"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new(
                "coverage_offset",
                FieldType::offset(self.coverage_offset(), self.coverage()),
            )),
            1usize => Some(Field::new(
                "italic_correction_count",
                self.italic_correction_count(),
            )),
            2usize => Some(Field::new(
                "italics_correction",
                traversal::FieldType::array_of_records(
                    stringify!(MathValueRecord),
                    self.italics_correction(),
                    self.offset_data(),
                ),
            )),
            _ => None,
        }
    }
}

#[cfg(feature = "experimental_traverse")]
#[allow(clippy::needless_lifetimes)]
impl<'a> std::fmt::Debug for MathItalicsCorrectionInfo<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

/// [MathTopAccentAttachment](https://learn.microsoft.com/en-gb/typography/opentype/spec/math#mathtopaccentattachment-table)
#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct MathTopAccentAttachmentMarker {
    top_accent_attachment_byte_len: usize,
}

impl MathTopAccentAttachmentMarker {
    pub fn top_accent_coverage_offset_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + Offset16::RAW_BYTE_LEN
    }

    pub fn top_accent_attachment_count_byte_range(&self) -> Range<usize> {
        let start = self.top_accent_coverage_offset_byte_range().end;
        start..start + u16::RAW_BYTE_LEN
    }

    pub fn top_accent_attachment_byte_range(&self) -> Range<usize> {
        let start = self.top_accent_attachment_count_byte_range().end;
        start..start + self.top_accent_attachment_byte_len
    }
}

impl<'a> FontRead<'a> for MathTopAccentAttachment<'a> {
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        let mut cursor = data.cursor();
        cursor.advance::<Offset16>();
        let top_accent_attachment_count: u16 = cursor.read()?;
        let top_accent_attachment_byte_len = (top_accent_attachment_count as usize)
            .checked_mul(MathValueRecord::RAW_BYTE_LEN)
            .ok_or(ReadError::OutOfBounds)?;
        cursor.advance_by(top_accent_attachment_byte_len);
        cursor.finish(MathTopAccentAttachmentMarker {
            top_accent_attachment_byte_len,
        })
    }
}

/// [MathTopAccentAttachment](https://learn.microsoft.com/en-gb/typography/opentype/spec/math#mathtopaccentattachment-table)
pub type MathTopAccentAttachment<'a> = TableRef<'a, MathTopAccentAttachmentMarker>;

#[allow(clippy::needless_lifetimes)]
impl<'a> MathTopAccentAttachment<'a> {
    /// Offset to Coverage table, from the beginning of MathTopAccentAttachment table
    pub fn top_accent_coverage_offset(&self) -> Offset16 {
        let range = self.shape.top_accent_coverage_offset_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Attempt to resolve [`top_accent_coverage_offset`][Self::top_accent_coverage_offset].
    pub fn top_accent_coverage(&self) -> Result<CoverageTable<'a>, ReadError> {
        let data = self.data;
        self.top_accent_coverage_offset().resolve(data)
    }

    /// Number of top accent attachment point values
    pub fn top_accent_attachment_count(&self) -> u16 {
        let range = self.shape.top_accent_attachment_count_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Array of MathValueRecords defining top accent attachment values for each covered glyph
    pub fn top_accent_attachment(&self) -> &'a [MathValueRecord] {
        let range = self.shape.top_accent_attachment_byte_range();
        self.data.read_array(range).unwrap()
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeTable<'a> for MathTopAccentAttachment<'a> {
    fn type_name(&self) -> &str {
        "MathTopAccentAttachment"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new(
                "top_accent_coverage_offset",
                FieldType::offset(
                    self.top_accent_coverage_offset(),
                    self.top_accent_coverage(),
                ),
            )),
            1usize => Some(Field::new(
                "top_accent_attachment_count",
                self.top_accent_attachment_count(),
            )),
            2usize => Some(Field::new(
                "top_accent_attachment",
                traversal::FieldType::array_of_records(
                    stringify!(MathValueRecord),
                    self.top_accent_attachment(),
                    self.offset_data(),
                ),
            )),
            _ => None,
        }
    }
}

#[cfg(feature = "experimental_traverse")]
#[allow(clippy::needless_lifetimes)]
impl<'a> std::fmt::Debug for MathTopAccentAttachment<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

/// [MathKernInfo](https://learn.microsoft.com/en-gb/typography/opentype/spec/math#mathkerninfo-table)
#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct MathKernInfoMarker {
    math_kern_info_byte_len: usize,
}

impl MathKernInfoMarker {
    pub fn coverage_offset_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + Offset16::RAW_BYTE_LEN
    }

    pub fn math_kern_count_byte_range(&self) -> Range<usize> {
        let start = self.coverage_offset_byte_range().end;
        start..start + u16::RAW_BYTE_LEN
    }

    pub fn math_kern_info_byte_range(&self) -> Range<usize> {
        let start = self.math_kern_count_byte_range().end;
        start..start + self.math_kern_info_byte_len
    }
}

impl<'a> FontRead<'a> for MathKernInfo<'a> {
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        let mut cursor = data.cursor();
        cursor.advance::<Offset16>();
        let math_kern_count: u16 = cursor.read()?;
        let math_kern_info_byte_len = (math_kern_count as usize)
            .checked_mul(MathKernInfoRecord::RAW_BYTE_LEN)
            .ok_or(ReadError::OutOfBounds)?;
        cursor.advance_by(math_kern_info_byte_len);
        cursor.finish(MathKernInfoMarker {
            math_kern_info_byte_len,
        })
    }
}

/// [MathKernInfo](https://learn.microsoft.com/en-gb/typography/opentype/spec/math#mathkerninfo-table)
pub type MathKernInfo<'a> = TableRef<'a, MathKernInfoMarker>;

#[allow(clippy::needless_lifetimes)]
impl<'a> MathKernInfo<'a> {
    /// Offset to Coverage table, from the beginning of the MathKernInfo table
    pub fn coverage_offset(&self) -> Offset16 {
        let range = self.shape.coverage_offset_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Attempt to resolve [`coverage_offset`][Self::coverage_offset].
    pub fn coverage(&self) -> Result<CoverageTable<'a>, ReadError> {
        let data = self.data;
        self.coverage_offset().resolve(data)
    }

    /// Number of MathKernInfoRecords
    pub fn math_kern_count(&self) -> u16 {
        let range = self.shape.math_kern_count_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Array of MathKernInfoRecords
    pub fn math_kern_info(&self) -> &'a [MathKernInfoRecord] {
        let range = self.shape.math_kern_info_byte_range();
        self.data.read_array(range).unwrap()
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeTable<'a> for MathKernInfo<'a> {
    fn type_name(&self) -> &str {
        "MathKernInfo"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new(
                "coverage_offset",
                FieldType::offset(self.coverage_offset(), self.coverage()),
            )),
            1usize => Some(Field::new("math_kern_count", self.math_kern_count())),
            2usize => Some(Field::new(
                "math_kern_info",
                traversal::FieldType::array_of_records(
                    stringify!(MathKernInfoRecord),
                    self.math_kern_info(),
                    self.offset_data(),
                ),
            )),
            _ => None,
        }
    }
}

#[cfg(feature = "experimental_traverse")]
#[allow(clippy::needless_lifetimes)]
impl<'a> std::fmt::Debug for MathKernInfo<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

/// [MathKernInfoRecord](https://learn.microsoft.com/en-gb/typography/opentype/spec/math#mathkerninfo-table)
#[derive(Clone, Debug, Copy, bytemuck :: AnyBitPattern)]
#[repr(C)]
#[repr(packed)]
pub struct MathKernInfoRecord {
    /// Offset to MathKern table for top right corner, from the beginning of the MathKernInfo table
    pub top_right_math_kern_offset: BigEndian<Offset16>,
    /// Offset to MathKern table for top left corner, from the beginning of the MathKernInfo table
    pub top_left_math_kern_offset: BigEndian<Offset16>,
    /// Offset to MathKern table for bottom right corner, from the beginning of the MathKernInfo table
    pub bottom_right_math_kern_offset: BigEndian<Offset16>,
    /// Offset to MathKern table for bottom left corner, from the beginning of the MathKernInfo table
    pub bottom_left_math_kern_offset: BigEndian<Offset16>,
}

impl MathKernInfoRecord {
    /// Offset to MathKern table for top right corner, from the beginning of the MathKernInfo table
    pub fn top_right_math_kern_offset(&self) -> Offset16 {
        self.top_right_math_kern_offset.get()
    }

    /// Offset to MathKern table for top right corner, from the beginning of the MathKernInfo table
    ///
    /// The `data` argument should be retrieved from the parent table
    /// By calling its `offset_data` method.
    pub fn top_right_math_kern<'a>(&self, data: FontData<'a>) -> Result<MathKern<'a>, ReadError> {
        self.top_right_math_kern_offset().resolve(data)
    }

    /// Offset to MathKern table for top left corner, from the beginning of the MathKernInfo table
    pub fn top_left_math_kern_offset(&self) -> Offset16 {
        self.top_left_math_kern_offset.get()
    }

    /// Offset to MathKern table for top left corner, from the beginning of the MathKernInfo table
    ///
    /// The `data` argument should be retrieved from the parent table
    /// By calling its `offset_data` method.
    pub fn top_left_math_kern<'a>(&self, data: FontData<'a>) -> Result<MathKern<'a>, ReadError> {
        self.top_left_math_kern_offset().resolve(data)
    }

    /// Offset to MathKern table for bottom right corner, from the beginning of the MathKernInfo table
    pub fn bottom_right_math_kern_offset(&self) -> Offset16 {
        self.bottom_right_math_kern_offset.get()
    }

    /// Offset to MathKern table for bottom right corner, from the beginning of the MathKernInfo table
    ///
    /// The `data` argument should be retrieved from the parent table
    /// By calling its `offset_data` method.
    pub fn bottom_right_math_kern<'a>(
        &self,
        data: FontData<'a>,
    ) -> Result<MathKern<'a>, ReadError> {
        self.bottom_right_math_kern_offset().resolve(data)
    }

    /// Offset to MathKern table for bottom left corner, from the beginning of the MathKernInfo table
    pub fn bottom_left_math_kern_offset(&self) -> Offset16 {
        self.bottom_left_math_kern_offset.get()
    }

    /// Offset to MathKern table for bottom left corner, from the beginning of the MathKernInfo table
    ///
    /// The `data` argument should be retrieved from the parent table
    /// By calling its `offset_data` method.
    pub fn bottom_left_math_kern<'a>(&self, data: FontData<'a>) -> Result<MathKern<'a>, ReadError> {
        self.bottom_left_math_kern_offset().resolve(data)
    }
}

impl FixedSize for MathKernInfoRecord {
    const RAW_BYTE_LEN: usize = Offset16::RAW_BYTE_LEN
        + Offset16::RAW_BYTE_LEN
        + Offset16::RAW_BYTE_LEN
        + Offset16::RAW_BYTE_LEN;
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeRecord<'a> for MathKernInfoRecord {
    fn traverse(self, data: FontData<'a>) -> RecordResolver<'a> {
        RecordResolver {
            name: "MathKernInfoRecord",
            get_field: Box::new(move |idx, _data| match idx {
                0usize => Some(Field::new(
                    "top_right_math_kern_offset",
                    FieldType::offset(
                        self.top_right_math_kern_offset(),
                        self.top_right_math_kern(_data),
                    ),
                )),
                1usize => Some(Field::new(
                    "top_left_math_kern_offset",
                    FieldType::offset(
                        self.top_left_math_kern_offset(),
                        self.top_left_math_kern(_data),
                    ),
                )),
                2usize => Some(Field::new(
                    "bottom_right_math_kern_offset",
                    FieldType::offset(
                        self.bottom_right_math_kern_offset(),
                        self.bottom_right_math_kern(_data),
                    ),
                )),
                3usize => Some(Field::new(
                    "bottom_left_math_kern_offset",
                    FieldType::offset(
                        self.bottom_left_math_kern_offset(),
                        self.bottom_left_math_kern(_data),
                    ),
                )),
                _ => None,
            }),
            data,
        }
    }
}

/// [MathKern](https://learn.microsoft.com/en-gb/typography/opentype/spec/math#mathkerninfo-table) table
#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct MathKernMarker {
    correction_heights_byte_len: usize,
    kern_values_byte_len: usize,
}

impl MathKernMarker {
    pub fn height_count_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + u16::RAW_BYTE_LEN
    }

    pub fn correction_heights_byte_range(&self) -> Range<usize> {
        let start = self.height_count_byte_range().end;
        start..start + self.correction_heights_byte_len
    }

    pub fn kern_values_byte_range(&self) -> Range<usize> {
        let start = self.correction_heights_byte_range().end;
        start..start + self.kern_values_byte_len
    }
}

impl<'a> FontRead<'a> for MathKern<'a> {
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        let mut cursor = data.cursor();
        let height_count: u16 = cursor.read()?;
        let correction_heights_byte_len = (height_count as usize)
            .checked_mul(MathValueRecord::RAW_BYTE_LEN)
            .ok_or(ReadError::OutOfBounds)?;
        cursor.advance_by(correction_heights_byte_len);
        let kern_values_byte_len = (transforms::add(height_count, 1_usize))
            .checked_mul(MathValueRecord::RAW_BYTE_LEN)
            .ok_or(ReadError::OutOfBounds)?;
        cursor.advance_by(kern_values_byte_len);
        cursor.finish(MathKernMarker {
            correction_heights_byte_len,
            kern_values_byte_len,
        })
    }
}

/// [MathKern](https://learn.microsoft.com/en-gb/typography/opentype/spec/math#mathkerninfo-table) table
pub type MathKern<'a> = TableRef<'a, MathKernMarker>;

#[allow(clippy::needless_lifetimes)]
impl<'a> MathKern<'a> {
    /// Number of heights at which the kern value changes
    pub fn height_count(&self) -> u16 {
        let range = self.shape.height_count_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Array of correction heights, in design units, sorted from lowest to highest
    pub fn correction_heights(&self) -> &'a [MathValueRecord] {
        let range = self.shape.correction_heights_byte_range();
        self.data.read_array(range).unwrap()
    }

    /// Array of kerning values for different height ranges
    pub fn kern_values(&self) -> &'a [MathValueRecord] {
        let range = self.shape.kern_values_byte_range();
        self.data.read_array(range).unwrap()
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeTable<'a> for MathKern<'a> {
    fn type_name(&self) -> &str {
        "MathKern"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new("height_count", self.height_count())),
            1usize => Some(Field::new(
                "correction_heights",
                traversal::FieldType::array_of_records(
                    stringify!(MathValueRecord),
                    self.correction_heights(),
                    self.offset_data(),
                ),
            )),
            2usize => Some(Field::new(
                "kern_values",
                traversal::FieldType::array_of_records(
                    stringify!(MathValueRecord),
                    self.kern_values(),
                    self.offset_data(),
                ),
            )),
            _ => None,
        }
    }
}

#[cfg(feature = "experimental_traverse")]
#[allow(clippy::needless_lifetimes)]
impl<'a> std::fmt::Debug for MathKern<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

/// [MathVariants](https://learn.microsoft.com/en-gb/typography/opentype/spec/math#mathvariants-table) table
#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct MathVariantsMarker {
    vert_glyph_construction_offsets_byte_len: usize,
    horiz_glyph_construction_offsets_byte_len: usize,
}

impl MathVariantsMarker {
    pub fn min_connector_overlap_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + UfWord::RAW_BYTE_LEN
    }

    pub fn vert_glyph_coverage_offset_byte_range(&self) -> Range<usize> {
        let start = self.min_connector_overlap_byte_range().end;
        start..start + Offset16::RAW_BYTE_LEN
    }

    pub fn horiz_glyph_coverage_offset_byte_range(&self) -> Range<usize> {
        let start = self.vert_glyph_coverage_offset_byte_range().end;
        start..start + Offset16::RAW_BYTE_LEN
    }

    pub fn vert_glyph_count_byte_range(&self) -> Range<usize> {
        let start = self.horiz_glyph_coverage_offset_byte_range().end;
        start..start + u16::RAW_BYTE_LEN
    }

    pub fn horiz_glyph_count_byte_range(&self) -> Range<usize> {
        let start = self.vert_glyph_count_byte_range().end;
        start..start + u16::RAW_BYTE_LEN
    }

    pub fn vert_glyph_construction_offsets_byte_range(&self) -> Range<usize> {
        let start = self.horiz_glyph_count_byte_range().end;
        start..start + self.vert_glyph_construction_offsets_byte_len
    }

    pub fn horiz_glyph_construction_offsets_byte_range(&self) -> Range<usize> {
        let start = self.vert_glyph_construction_offsets_byte_range().end;
        start..start + self.horiz_glyph_construction_offsets_byte_len
    }
}

impl<'a> FontRead<'a> for MathVariants<'a> {
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        let mut cursor = data.cursor();
        cursor.advance::<UfWord>();
        cursor.advance::<Offset16>();
        cursor.advance::<Offset16>();
        let vert_glyph_count: u16 = cursor.read()?;
        let horiz_glyph_count: u16 = cursor.read()?;
        let vert_glyph_construction_offsets_byte_len = (vert_glyph_count as usize)
            .checked_mul(Offset16::RAW_BYTE_LEN)
            .ok_or(ReadError::OutOfBounds)?;
        cursor.advance_by(vert_glyph_construction_offsets_byte_len);
        let horiz_glyph_construction_offsets_byte_len = (horiz_glyph_count as usize)
            .checked_mul(Offset16::RAW_BYTE_LEN)
            .ok_or(ReadError::OutOfBounds)?;
        cursor.advance_by(horiz_glyph_construction_offsets_byte_len);
        cursor.finish(MathVariantsMarker {
            vert_glyph_construction_offsets_byte_len,
            horiz_glyph_construction_offsets_byte_len,
        })
    }
}

/// [MathVariants](https://learn.microsoft.com/en-gb/typography/opentype/spec/math#mathvariants-table) table
pub type MathVariants<'a> = TableRef<'a, MathVariantsMarker>;

#[allow(clippy::needless_lifetimes)]
impl<'a> MathVariants<'a> {
    /// Minimum overlap of connecting glyphs during glyph construction, in design units
    pub fn min_connector_overlap(&self) -> UfWord {
        let range = self.shape.min_connector_overlap_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Offset to Coverage table, from the beginning of the MathVariants table
    pub fn vert_glyph_coverage_offset(&self) -> Offset16 {
        let range = self.shape.vert_glyph_coverage_offset_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Attempt to resolve [`vert_glyph_coverage_offset`][Self::vert_glyph_coverage_offset].
    pub fn vert_glyph_coverage(&self) -> Result<CoverageTable<'a>, ReadError> {
        let data = self.data;
        self.vert_glyph_coverage_offset().resolve(data)
    }

    /// Offset to Coverage table, from the beginning of the MathVariants table
    pub fn horiz_glyph_coverage_offset(&self) -> Offset16 {
        let range = self.shape.horiz_glyph_coverage_offset_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Attempt to resolve [`horiz_glyph_coverage_offset`][Self::horiz_glyph_coverage_offset].
    pub fn horiz_glyph_coverage(&self) -> Result<CoverageTable<'a>, ReadError> {
        let data = self.data;
        self.horiz_glyph_coverage_offset().resolve(data)
    }

    /// Number of glyphs for which information is provided for vertically growing variants
    pub fn vert_glyph_count(&self) -> u16 {
        let range = self.shape.vert_glyph_count_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Number of glyphs for which information is provided for horizontally growing variants
    pub fn horiz_glyph_count(&self) -> u16 {
        let range = self.shape.horiz_glyph_count_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Array of offsets to MathGlyphConstruction tables, from the beginning of the MathVariants table, for shapes growing in the vertical direction
    pub fn vert_glyph_construction_offsets(&self) -> &'a [BigEndian<Offset16>] {
        let range = self.shape.vert_glyph_construction_offsets_byte_range();
        self.data.read_array(range).unwrap()
    }

    /// A dynamically resolving wrapper for [`vert_glyph_construction_offsets`][Self::vert_glyph_construction_offsets].
    pub fn vert_glyph_constructions(
        &self,
    ) -> ArrayOfOffsets<'a, MathGlyphConstruction<'a>, Offset16> {
        let data = self.data;
        let offsets = self.vert_glyph_construction_offsets();
        ArrayOfOffsets::new(offsets, data, ())
    }

    /// Array of offsets to MathGlyphConstruction tables, from the beginning of the MathVariants table, for shapes growing in the horizontal direction
    pub fn horiz_glyph_construction_offsets(&self) -> &'a [BigEndian<Offset16>] {
        let range = self.shape.horiz_glyph_construction_offsets_byte_range();
        self.data.read_array(range).unwrap()
    }

    /// A dynamically resolving wrapper for [`horiz_glyph_construction_offsets`][Self::horiz_glyph_construction_offsets].
    pub fn horiz_glyph_constructions(
        &self,
    ) -> ArrayOfOffsets<'a, MathGlyphConstruction<'a>, Offset16> {
        let data = self.data;
        let offsets = self.horiz_glyph_construction_offsets();
        ArrayOfOffsets::new(offsets, data, ())
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeTable<'a> for MathVariants<'a> {
    fn type_name(&self) -> &str {
        "MathVariants"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new(
                "min_connector_overlap",
                self.min_connector_overlap(),
            )),
            1usize => Some(Field::new(
                "vert_glyph_coverage_offset",
                FieldType::offset(
                    self.vert_glyph_coverage_offset(),
                    self.vert_glyph_coverage(),
                ),
            )),
            2usize => Some(Field::new(
                "horiz_glyph_coverage_offset",
                FieldType::offset(
                    self.horiz_glyph_coverage_offset(),
                    self.horiz_glyph_coverage(),
                ),
            )),
            3usize => Some(Field::new("vert_glyph_count", self.vert_glyph_count())),
            4usize => Some(Field::new("horiz_glyph_count", self.horiz_glyph_count())),
            5usize => Some({
                let data = self.data;
                Field::new(
                    "vert_glyph_construction_offsets",
                    FieldType::array_of_offsets(
                        better_type_name::<MathGlyphConstruction>(),
                        self.vert_glyph_construction_offsets(),
                        move |off| {
                            let target = off.get().resolve::<MathGlyphConstruction>(data);
                            FieldType::offset(off.get(), target)
                        },
                    ),
                )
            }),
            6usize => Some({
                let data = self.data;
                Field::new(
                    "horiz_glyph_construction_offsets",
                    FieldType::array_of_offsets(
                        better_type_name::<MathGlyphConstruction>(),
                        self.horiz_glyph_construction_offsets(),
                        move |off| {
                            let target = off.get().resolve::<MathGlyphConstruction>(data);
                            FieldType::offset(off.get(), target)
                        },
                    ),
                )
            }),
            _ => None,
        }
    }
}

#[cfg(feature = "experimental_traverse")]
#[allow(clippy::needless_lifetimes)]
impl<'a> std::fmt::Debug for MathVariants<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

/// The [MathGlyphConstruction](https://learn.microsoft.com/en-gb/typography/opentype/spec/math#mathglyphconstruction-table) table
#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct MathGlyphConstructionMarker {
    math_glyph_variant_records_byte_len: usize,
}

impl MathGlyphConstructionMarker {
    pub fn glyph_assembly_offset_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + Offset16::RAW_BYTE_LEN
    }

    pub fn variant_count_byte_range(&self) -> Range<usize> {
        let start = self.glyph_assembly_offset_byte_range().end;
        start..start + u16::RAW_BYTE_LEN
    }

    pub fn math_glyph_variant_records_byte_range(&self) -> Range<usize> {
        let start = self.variant_count_byte_range().end;
        start..start + self.math_glyph_variant_records_byte_len
    }
}

impl<'a> FontRead<'a> for MathGlyphConstruction<'a> {
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        let mut cursor = data.cursor();
        cursor.advance::<Offset16>();
        let variant_count: u16 = cursor.read()?;
        let math_glyph_variant_records_byte_len = (variant_count as usize)
            .checked_mul(MathGlyphVariantRecord::RAW_BYTE_LEN)
            .ok_or(ReadError::OutOfBounds)?;
        cursor.advance_by(math_glyph_variant_records_byte_len);
        cursor.finish(MathGlyphConstructionMarker {
            math_glyph_variant_records_byte_len,
        })
    }
}

/// The [MathGlyphConstruction](https://learn.microsoft.com/en-gb/typography/opentype/spec/math#mathglyphconstruction-table) table
pub type MathGlyphConstruction<'a> = TableRef<'a, MathGlyphConstructionMarker>;

#[allow(clippy::needless_lifetimes)]
impl<'a> MathGlyphConstruction<'a> {
    /// Offset to the GlyphAssembly table for this shape, from the beginning of the MathGlyphConstruction table
    pub fn glyph_assembly_offset(&self) -> Nullable<Offset16> {
        let range = self.shape.glyph_assembly_offset_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Attempt to resolve [`glyph_assembly_offset`][Self::glyph_assembly_offset].
    pub fn glyph_assembly(&self) -> Option<Result<GlyphAssembly<'a>, ReadError>> {
        let data = self.data;
        self.glyph_assembly_offset().resolve(data)
    }

    /// Count of glyph growing variants for this glyph
    pub fn variant_count(&self) -> u16 {
        let range = self.shape.variant_count_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// MathGlyphVariantRecords for alternative variants of the glyphs
    pub fn math_glyph_variant_records(&self) -> &'a [MathGlyphVariantRecord] {
        let range = self.shape.math_glyph_variant_records_byte_range();
        self.data.read_array(range).unwrap()
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeTable<'a> for MathGlyphConstruction<'a> {
    fn type_name(&self) -> &str {
        "MathGlyphConstruction"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new(
                "glyph_assembly_offset",
                FieldType::offset(self.glyph_assembly_offset(), self.glyph_assembly()),
            )),
            1usize => Some(Field::new("variant_count", self.variant_count())),
            2usize => Some(Field::new(
                "math_glyph_variant_records",
                traversal::FieldType::array_of_records(
                    stringify!(MathGlyphVariantRecord),
                    self.math_glyph_variant_records(),
                    self.offset_data(),
                ),
            )),
            _ => None,
        }
    }
}

#[cfg(feature = "experimental_traverse")]
#[allow(clippy::needless_lifetimes)]
impl<'a> std::fmt::Debug for MathGlyphConstruction<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

/// [MathGlyphVariantRecord](https://learn.microsoft.com/en-gb/typography/opentype/spec/math#mathglyphconstruction-table)
#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Copy, bytemuck :: AnyBitPattern)]
#[repr(C)]
#[repr(packed)]
pub struct MathGlyphVariantRecord {
    /// Glyph ID for the variant
    pub glyph_id: BigEndian<GlyphId16>,
    /// Advance width/height, in design units, of the variant, in the direction of requested glyph extension
    pub advance_measurement: BigEndian<UfWord>,
}

impl MathGlyphVariantRecord {
    /// Glyph ID for the variant
    pub fn glyph_id(&self) -> GlyphId16 {
        self.glyph_id.get()
    }

    /// Advance width/height, in design units, of the variant, in the direction of requested glyph extension
    pub fn advance_measurement(&self) -> UfWord {
        self.advance_measurement.get()
    }
}

impl FixedSize for MathGlyphVariantRecord {
    const RAW_BYTE_LEN: usize = GlyphId16::RAW_BYTE_LEN + UfWord::RAW_BYTE_LEN;
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeRecord<'a> for MathGlyphVariantRecord {
    fn traverse(self, data: FontData<'a>) -> RecordResolver<'a> {
        RecordResolver {
            name: "MathGlyphVariantRecord",
            get_field: Box::new(move |idx, _data| match idx {
                0usize => Some(Field::new("glyph_id", self.glyph_id())),
                1usize => Some(Field::new(
                    "advance_measurement",
                    self.advance_measurement(),
                )),
                _ => None,
            }),
            data,
        }
    }
}

/// The [GlyphAssembly](https://learn.microsoft.com/en-gb/typography/opentype/spec/math#glyphassembly-table) table
#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct GlyphAssemblyMarker {
    part_records_byte_len: usize,
}

impl GlyphAssemblyMarker {
    pub fn italic_correction_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + self.italic_correction_byte_len
    }

    pub fn part_count_byte_range(&self) -> Range<usize> {
        let start = self.italic_correction_byte_range().end;
        start..start + u16::RAW_BYTE_LEN
    }

    pub fn part_records_byte_range(&self) -> Range<usize> {
        let start = self.part_count_byte_range().end;
        start..start + self.part_records_byte_len
    }
}

impl<'a> FontRead<'a> for GlyphAssembly<'a> {
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        let mut cursor = data.cursor();
        cursor.advance::<MathValueRecord>();
        let part_count: u16 = cursor.read()?;
        let part_records_byte_len = (part_count as usize)
            .checked_mul(GlyphPart::RAW_BYTE_LEN)
            .ok_or(ReadError::OutOfBounds)?;
        cursor.advance_by(part_records_byte_len);
        cursor.finish(GlyphAssemblyMarker {
            part_records_byte_len,
        })
    }
}

/// The [GlyphAssembly](https://learn.microsoft.com/en-gb/typography/opentype/spec/math#glyphassembly-table) table
pub type GlyphAssembly<'a> = TableRef<'a, GlyphAssemblyMarker>;

#[allow(clippy::needless_lifetimes)]
impl<'a> GlyphAssembly<'a> {
    /// Italic correction value for the assembly, in design units
    pub fn italic_correction(&self) -> MathValueRecord {
        let range = self.shape.italic_correction_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Count of parts in the assembly
    pub fn part_count(&self) -> u16 {
        let range = self.shape.part_count_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Array of GlyphPart records, from left to right (for assemblies that extend horizontally) or bottom to top (for assemblies that extend vertically)
    pub fn part_records(&self) -> &'a [GlyphPart] {
        let range = self.shape.part_records_byte_range();
        self.data.read_array(range).unwrap()
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeTable<'a> for GlyphAssembly<'a> {
    fn type_name(&self) -> &str {
        "GlyphAssembly"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(compile_error!(concat!(
                "another weird type: ",
                "italic_correction"
            ))),
            1usize => Some(Field::new("part_count", self.part_count())),
            2usize => Some(Field::new(
                "part_records",
                traversal::FieldType::array_of_records(
                    stringify!(GlyphPart),
                    self.part_records(),
                    self.offset_data(),
                ),
            )),
            _ => None,
        }
    }
}

#[cfg(feature = "experimental_traverse")]
#[allow(clippy::needless_lifetimes)]
impl<'a> std::fmt::Debug for GlyphAssembly<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Copy, bytemuck :: AnyBitPattern)]
#[repr(C)]
#[repr(packed)]
pub struct GlyphPart {
    /// Glyph ID of the part
    pub glyph_id: BigEndian<GlyphId16>,
    /// Advance width / height, in design units, of the straight bar connector material at the start of the glyph in the direction of the extension
    pub start_connector_length: BigEndian<UfWord>,
    /// Advance width / height, in design units, of the straight bar connector material at the end of the glyph in the direction of the extension
    pub end_connector_length: BigEndian<UfWord>,
    /// Full advance width/height for this part in the direction of the extension, in design units
    pub full_advance: BigEndian<UfWord>,
    /// Part qualifiers
    pub part_flags: BigEndian<GlyphPartFlags>,
}

impl GlyphPart {
    /// Glyph ID of the part
    pub fn glyph_id(&self) -> GlyphId16 {
        self.glyph_id.get()
    }

    /// Advance width / height, in design units, of the straight bar connector material at the start of the glyph in the direction of the extension
    pub fn start_connector_length(&self) -> UfWord {
        self.start_connector_length.get()
    }

    /// Advance width / height, in design units, of the straight bar connector material at the end of the glyph in the direction of the extension
    pub fn end_connector_length(&self) -> UfWord {
        self.end_connector_length.get()
    }

    /// Full advance width/height for this part in the direction of the extension, in design units
    pub fn full_advance(&self) -> UfWord {
        self.full_advance.get()
    }

    /// Part qualifiers
    pub fn part_flags(&self) -> GlyphPartFlags {
        self.part_flags.get()
    }
}

impl FixedSize for GlyphPart {
    const RAW_BYTE_LEN: usize = GlyphId16::RAW_BYTE_LEN
        + UfWord::RAW_BYTE_LEN
        + UfWord::RAW_BYTE_LEN
        + UfWord::RAW_BYTE_LEN
        + GlyphPartFlags::RAW_BYTE_LEN;
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeRecord<'a> for GlyphPart {
    fn traverse(self, data: FontData<'a>) -> RecordResolver<'a> {
        RecordResolver {
            name: "GlyphPart",
            get_field: Box::new(move |idx, _data| match idx {
                0usize => Some(Field::new("glyph_id", self.glyph_id())),
                1usize => Some(Field::new(
                    "start_connector_length",
                    self.start_connector_length(),
                )),
                2usize => Some(Field::new(
                    "end_connector_length",
                    self.end_connector_length(),
                )),
                3usize => Some(Field::new("full_advance", self.full_advance())),
                4usize => Some(Field::new("part_flags", self.part_flags())),
                _ => None,
            }),
            data,
        }
    }
}

/// [Glyph Part flags](https://learn.microsoft.com/en-gb/typography/opentype/spec/math#glyphassembly-table).
#[derive(Clone, Copy, Default, PartialEq, Eq, PartialOrd, Ord, Hash, bytemuck :: AnyBitPattern)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
#[repr(transparent)]
pub struct GlyphPartFlags {
    bits: u16,
}

impl GlyphPartFlags {
    /// Extender; this part can be skipped or repeated
    pub const EXTENDER_FLAG: Self = Self { bits: 0x01 };
}

impl GlyphPartFlags {
    ///  Returns an empty set of flags.
    #[inline]
    pub const fn empty() -> Self {
        Self { bits: 0 }
    }

    /// Returns the set containing all flags.
    #[inline]
    pub const fn all() -> Self {
        Self {
            bits: Self::EXTENDER_FLAG.bits,
        }
    }

    /// Returns the raw value of the flags currently stored.
    #[inline]
    pub const fn bits(&self) -> u16 {
        self.bits
    }

    /// Convert from underlying bit representation, unless that
    /// representation contains bits that do not correspond to a flag.
    #[inline]
    pub const fn from_bits(bits: u16) -> Option<Self> {
        if (bits & !Self::all().bits()) == 0 {
            Some(Self { bits })
        } else {
            None
        }
    }

    /// Convert from underlying bit representation, dropping any bits
    /// that do not correspond to flags.
    #[inline]
    pub const fn from_bits_truncate(bits: u16) -> Self {
        Self {
            bits: bits & Self::all().bits,
        }
    }

    /// Returns `true` if no flags are currently stored.
    #[inline]
    pub const fn is_empty(&self) -> bool {
        self.bits() == Self::empty().bits()
    }

    /// Returns `true` if there are flags common to both `self` and `other`.
    #[inline]
    pub const fn intersects(&self, other: Self) -> bool {
        !(Self {
            bits: self.bits & other.bits,
        })
        .is_empty()
    }

    /// Returns `true` if all of the flags in `other` are contained within `self`.
    #[inline]
    pub const fn contains(&self, other: Self) -> bool {
        (self.bits & other.bits) == other.bits
    }

    /// Inserts the specified flags in-place.
    #[inline]
    pub fn insert(&mut self, other: Self) {
        self.bits |= other.bits;
    }

    /// Removes the specified flags in-place.
    #[inline]
    pub fn remove(&mut self, other: Self) {
        self.bits &= !other.bits;
    }

    /// Toggles the specified flags in-place.
    #[inline]
    pub fn toggle(&mut self, other: Self) {
        self.bits ^= other.bits;
    }

    /// Returns the intersection between the flags in `self` and
    /// `other`.
    ///
    /// Specifically, the returned set contains only the flags which are
    /// present in *both* `self` *and* `other`.
    ///
    /// This is equivalent to using the `&` operator (e.g.
    /// [`ops::BitAnd`]), as in `flags & other`.
    ///
    /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html
    #[inline]
    #[must_use]
    pub const fn intersection(self, other: Self) -> Self {
        Self {
            bits: self.bits & other.bits,
        }
    }

    /// Returns the union of between the flags in `self` and `other`.
    ///
    /// Specifically, the returned set contains all flags which are
    /// present in *either* `self` *or* `other`, including any which are
    /// present in both.
    ///
    /// This is equivalent to using the `|` operator (e.g.
    /// [`ops::BitOr`]), as in `flags | other`.
    ///
    /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html
    #[inline]
    #[must_use]
    pub const fn union(self, other: Self) -> Self {
        Self {
            bits: self.bits | other.bits,
        }
    }

    /// Returns the difference between the flags in `self` and `other`.
    ///
    /// Specifically, the returned set contains all flags present in
    /// `self`, except for the ones present in `other`.
    ///
    /// It is also conceptually equivalent to the "bit-clear" operation:
    /// `flags & !other` (and this syntax is also supported).
    ///
    /// This is equivalent to using the `-` operator (e.g.
    /// [`ops::Sub`]), as in `flags - other`.
    ///
    /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html
    #[inline]
    #[must_use]
    pub const fn difference(self, other: Self) -> Self {
        Self {
            bits: self.bits & !other.bits,
        }
    }
}

impl std::ops::BitOr for GlyphPartFlags {
    type Output = Self;

    /// Returns the union of the two sets of flags.
    #[inline]
    fn bitor(self, other: GlyphPartFlags) -> Self {
        Self {
            bits: self.bits | other.bits,
        }
    }
}

impl std::ops::BitOrAssign for GlyphPartFlags {
    /// Adds the set of flags.
    #[inline]
    fn bitor_assign(&mut self, other: Self) {
        self.bits |= other.bits;
    }
}

impl std::ops::BitXor for GlyphPartFlags {
    type Output = Self;

    /// Returns the left flags, but with all the right flags toggled.
    #[inline]
    fn bitxor(self, other: Self) -> Self {
        Self {
            bits: self.bits ^ other.bits,
        }
    }
}

impl std::ops::BitXorAssign for GlyphPartFlags {
    /// Toggles the set of flags.
    #[inline]
    fn bitxor_assign(&mut self, other: Self) {
        self.bits ^= other.bits;
    }
}

impl std::ops::BitAnd for GlyphPartFlags {
    type Output = Self;

    /// Returns the intersection between the two sets of flags.
    #[inline]
    fn bitand(self, other: Self) -> Self {
        Self {
            bits: self.bits & other.bits,
        }
    }
}

impl std::ops::BitAndAssign for GlyphPartFlags {
    /// Disables all flags disabled in the set.
    #[inline]
    fn bitand_assign(&mut self, other: Self) {
        self.bits &= other.bits;
    }
}

impl std::ops::Sub for GlyphPartFlags {
    type Output = Self;

    /// Returns the set difference of the two sets of flags.
    #[inline]
    fn sub(self, other: Self) -> Self {
        Self {
            bits: self.bits & !other.bits,
        }
    }
}

impl std::ops::SubAssign for GlyphPartFlags {
    /// Disables all flags enabled in the set.
    #[inline]
    fn sub_assign(&mut self, other: Self) {
        self.bits &= !other.bits;
    }
}

impl std::ops::Not for GlyphPartFlags {
    type Output = Self;

    /// Returns the complement of this set of flags.
    #[inline]
    fn not(self) -> Self {
        Self { bits: !self.bits } & Self::all()
    }
}

impl std::fmt::Debug for GlyphPartFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        let members: &[(&str, Self)] = &[("EXTENDER_FLAG", Self::EXTENDER_FLAG)];
        let mut first = true;
        for (name, value) in members {
            if self.contains(*value) {
                if !first {
                    f.write_str(" | ")?;
                }
                first = false;
                f.write_str(name)?;
            }
        }
        if first {
            f.write_str("(empty)")?;
        }
        Ok(())
    }
}

impl std::fmt::Binary for GlyphPartFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        std::fmt::Binary::fmt(&self.bits, f)
    }
}

impl std::fmt::Octal for GlyphPartFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        std::fmt::Octal::fmt(&self.bits, f)
    }
}

impl std::fmt::LowerHex for GlyphPartFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        std::fmt::LowerHex::fmt(&self.bits, f)
    }
}

impl std::fmt::UpperHex for GlyphPartFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        std::fmt::UpperHex::fmt(&self.bits, f)
    }
}

impl font_types::Scalar for GlyphPartFlags {
    type Raw = <u16 as font_types::Scalar>::Raw;
    fn to_raw(self) -> Self::Raw {
        self.bits().to_raw()
    }
    fn from_raw(raw: Self::Raw) -> Self {
        let t = <u16>::from_raw(raw);
        Self::from_bits_truncate(t)
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> From<GlyphPartFlags> for FieldType<'a> {
    fn from(src: GlyphPartFlags) -> FieldType<'a> {
        src.bits().into()
    }
}

/// [Math Value Record](https://learn.microsoft.com/en-gb/typography/opentype/spec/math#mathvaluerecord)
#[derive(Clone, Debug, Copy, bytemuck :: AnyBitPattern)]
#[repr(C)]
#[repr(packed)]
pub struct MathValueRecord {
    /// The X or Y value in design units
    pub value: BigEndian<FWord>,
    /// Offset to the device table, from the beginning of parent table
    pub device_table_offset: BigEndian<Nullable<Offset16>>,
}

impl MathValueRecord {
    /// The X or Y value in design units
    pub fn value(&self) -> FWord {
        self.value.get()
    }

    /// Offset to the device table, from the beginning of parent table
    pub fn device_table_offset(&self) -> Nullable<Offset16> {
        self.device_table_offset.get()
    }

    /// Offset to the device table, from the beginning of parent table
    ///
    /// The `data` argument should be retrieved from the parent table
    /// By calling its `offset_data` method.
    pub fn device_table<'a>(
        &self,
        data: FontData<'a>,
    ) -> Option<Result<DeviceTable<'a>, ReadError>> {
        self.device_table_offset().resolve(data)
    }
}

impl FixedSize for MathValueRecord {
    const RAW_BYTE_LEN: usize = FWord::RAW_BYTE_LEN + Offset16::RAW_BYTE_LEN;
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeRecord<'a> for MathValueRecord {
    fn traverse(self, data: FontData<'a>) -> RecordResolver<'a> {
        RecordResolver {
            name: "MathValueRecord",
            get_field: Box::new(move |idx, _data| match idx {
                0usize => Some(Field::new("value", self.value())),
                1usize => Some(Field::new(
                    "device_table_offset",
                    FieldType::offset(self.device_table_offset(), self.device_table(_data)),
                )),
                _ => None,
            }),
            data,
        }
    }
}
