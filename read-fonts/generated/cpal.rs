// THIS FILE IS AUTOGENERATED.
// Any changes to this file will be overwritten.
// For more information about how codegen works, see font-codegen/README.md

#[allow(unused_imports)]
use crate::codegen_prelude::*;

/// [CPAL (Color Palette Table)](https://learn.microsoft.com/en-us/typography/opentype/spec/cpal#palette-table-header) table
#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct CpalMarker {
    color_record_indices_byte_len: usize,
    palette_types_array_offset_byte_start: Option<usize>,
    palette_labels_array_offset_byte_start: Option<usize>,
    palette_entry_labels_array_offset_byte_start: Option<usize>,
}

impl CpalMarker {
    fn version_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + u16::RAW_BYTE_LEN
    }
    fn num_palette_entries_byte_range(&self) -> Range<usize> {
        let start = self.version_byte_range().end;
        start..start + u16::RAW_BYTE_LEN
    }
    fn num_palettes_byte_range(&self) -> Range<usize> {
        let start = self.num_palette_entries_byte_range().end;
        start..start + u16::RAW_BYTE_LEN
    }
    fn num_color_records_byte_range(&self) -> Range<usize> {
        let start = self.num_palettes_byte_range().end;
        start..start + u16::RAW_BYTE_LEN
    }
    fn color_records_array_offset_byte_range(&self) -> Range<usize> {
        let start = self.num_color_records_byte_range().end;
        start..start + Offset32::RAW_BYTE_LEN
    }
    fn color_record_indices_byte_range(&self) -> Range<usize> {
        let start = self.color_records_array_offset_byte_range().end;
        start..start + self.color_record_indices_byte_len
    }
    fn palette_types_array_offset_byte_range(&self) -> Option<Range<usize>> {
        let start = self.palette_types_array_offset_byte_start?;
        Some(start..start + Offset32::RAW_BYTE_LEN)
    }
    fn palette_labels_array_offset_byte_range(&self) -> Option<Range<usize>> {
        let start = self.palette_labels_array_offset_byte_start?;
        Some(start..start + Offset32::RAW_BYTE_LEN)
    }
    fn palette_entry_labels_array_offset_byte_range(&self) -> Option<Range<usize>> {
        let start = self.palette_entry_labels_array_offset_byte_start?;
        Some(start..start + Offset32::RAW_BYTE_LEN)
    }
}

impl<'a> FontRead<'a> for Cpal<'a> {
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        let mut cursor = data.cursor();
        let version: u16 = cursor.read()?;
        cursor.advance::<u16>();
        let num_palettes: u16 = cursor.read()?;
        cursor.advance::<u16>();
        cursor.advance::<Offset32>();
        let color_record_indices_byte_len = num_palettes as usize * u16::RAW_BYTE_LEN;
        cursor.advance_by(color_record_indices_byte_len);
        let palette_types_array_offset_byte_start = version
            .compatible(1)
            .then(|| cursor.position())
            .transpose()?;
        version.compatible(1).then(|| cursor.advance::<Offset32>());
        let palette_labels_array_offset_byte_start = version
            .compatible(1)
            .then(|| cursor.position())
            .transpose()?;
        version.compatible(1).then(|| cursor.advance::<Offset32>());
        let palette_entry_labels_array_offset_byte_start = version
            .compatible(1)
            .then(|| cursor.position())
            .transpose()?;
        version.compatible(1).then(|| cursor.advance::<Offset32>());
        cursor.finish(CpalMarker {
            color_record_indices_byte_len,
            palette_types_array_offset_byte_start,
            palette_labels_array_offset_byte_start,
            palette_entry_labels_array_offset_byte_start,
        })
    }
}

/// [CPAL (Color Palette Table)](https://learn.microsoft.com/en-us/typography/opentype/spec/cpal#palette-table-header) table
pub type Cpal<'a> = TableRef<'a, CpalMarker>;

impl<'a> Cpal<'a> {
    /// Table version number (=0).
    pub fn version(&self) -> u16 {
        let range = self.shape.version_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Number of palette entries in each palette.
    pub fn num_palette_entries(&self) -> u16 {
        let range = self.shape.num_palette_entries_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Number of palettes in the table.
    pub fn num_palettes(&self) -> u16 {
        let range = self.shape.num_palettes_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Total number of color records, combined for all palettes.
    pub fn num_color_records(&self) -> u16 {
        let range = self.shape.num_color_records_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Offset from the beginning of CPAL table to the first
    /// ColorRecord.
    pub fn color_records_array_offset(&self) -> Nullable<Offset32> {
        let range = self.shape.color_records_array_offset_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Attempt to resolve [`color_records_array_offset`][Self::color_records_array_offset].
    pub fn color_records_array(&self) -> Option<Result<ColorRecord<'a>, ReadError>> {
        let data = self.data;
        let args = self.num_color_records();
        self.color_records_array_offset()
            .resolve_with_args(data, &args)
    }

    /// Index of each palette’s first color record in the combined
    /// color record array.
    pub fn color_record_indices(&self) -> &'a [BigEndian<u16>] {
        let range = self.shape.color_record_indices_byte_range();
        self.data.read_array(range).unwrap()
    }

    /// Offset from the beginning of CPAL table to the Palette Types
    /// Array. Set to 0 if no array is provided.
    pub fn palette_types_array_offset(&self) -> Option<Nullable<Offset32>> {
        let range = self.shape.palette_types_array_offset_byte_range()?;
        Some(self.data.read_at(range.start).unwrap())
    }

    /// Attempt to resolve [`palette_types_array_offset`][Self::palette_types_array_offset].
    pub fn palette_types_array(&self) -> Option<Result<PaletteTypeArray<'a>, ReadError>> {
        let data = self.data;
        self.palette_types_array_offset().map(|x| x.resolve(data))?
    }

    /// Offset from the beginning of CPAL table to the Palette Labels
    /// Array. Set to 0 if no array is provided.
    pub fn palette_labels_array_offset(&self) -> Option<Nullable<Offset32>> {
        let range = self.shape.palette_labels_array_offset_byte_range()?;
        Some(self.data.read_at(range.start).unwrap())
    }

    /// Attempt to resolve [`palette_labels_array_offset`][Self::palette_labels_array_offset].
    pub fn palette_labels_array(&self) -> Option<Result<PaletteLabelArray<'a>, ReadError>> {
        let data = self.data;
        self.palette_labels_array_offset()
            .map(|x| x.resolve(data))?
    }

    /// Offset from the beginning of CPAL table to the Palette Entry
    /// Labels Array. Set to 0 if no array is provided.
    pub fn palette_entry_labels_array_offset(&self) -> Option<Nullable<Offset32>> {
        let range = self.shape.palette_entry_labels_array_offset_byte_range()?;
        Some(self.data.read_at(range.start).unwrap())
    }

    /// Attempt to resolve [`palette_entry_labels_array_offset`][Self::palette_entry_labels_array_offset].
    pub fn palette_entry_labels_array(
        &self,
    ) -> Option<Result<PaletteLabelEntryArray<'a>, ReadError>> {
        let data = self.data;
        self.palette_entry_labels_array_offset()
            .map(|x| x.resolve(data))?
    }
}

#[cfg(feature = "traversal")]
impl<'a> SomeTable<'a> for Cpal<'a> {
    fn type_name(&self) -> &str {
        "Cpal"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        let version = self.version();
        match idx {
            0usize => Some(Field::new("version", self.version())),
            1usize => Some(Field::new(
                "num_palette_entries",
                self.num_palette_entries(),
            )),
            2usize => Some(Field::new("num_palettes", self.num_palettes())),
            3usize => Some(Field::new("num_color_records", self.num_color_records())),
            4usize => Some(Field::new(
                "color_records_array_offset",
                FieldType::offset(
                    self.color_records_array_offset(),
                    self.color_records_array(),
                ),
            )),
            5usize => Some(Field::new(
                "color_record_indices",
                self.color_record_indices(),
            )),
            6usize if version.compatible(1) => Some(Field::new(
                "palette_types_array_offset",
                FieldType::offset(
                    self.palette_types_array_offset().unwrap(),
                    self.palette_types_array().unwrap(),
                ),
            )),
            7usize if version.compatible(1) => Some(Field::new(
                "palette_labels_array_offset",
                FieldType::offset(
                    self.palette_labels_array_offset().unwrap(),
                    self.palette_labels_array().unwrap(),
                ),
            )),
            8usize if version.compatible(1) => Some(Field::new(
                "palette_entry_labels_array_offset",
                FieldType::offset(
                    self.palette_entry_labels_array_offset().unwrap(),
                    self.palette_entry_labels_array().unwrap(),
                ),
            )),
            _ => None,
        }
    }
}

#[cfg(feature = "traversal")]
impl<'a> std::fmt::Debug for Cpal<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

/// [CPAL (Color Record)](https://learn.microsoft.com/en-us/typography/opentype/spec/cpal#palette-entries-and-color-records) record
#[derive(Clone, Debug)]
#[repr(C)]
#[repr(packed)]
pub struct ColorRecord {
    /// Blue value (B0).
    pub blue: BigEndian<u8>,
    /// Green value (B1).
    pub green: BigEndian<u8>,
    ///     Red value (B2).
    pub red: BigEndian<u8>,
    /// Alpha value (B3).
    pub alpha: BigEndian<u8>,
}

impl ColorRecord {
    /// Blue value (B0).
    pub fn blue(&self) -> u8 {
        self.blue.get()
    }

    /// Green value (B1).
    pub fn green(&self) -> u8 {
        self.green.get()
    }

    ///     Red value (B2).
    pub fn red(&self) -> u8 {
        self.red.get()
    }

    /// Alpha value (B3).
    pub fn alpha(&self) -> u8 {
        self.alpha.get()
    }
}

impl FixedSize for ColorRecord {
    const RAW_BYTE_LEN: usize =
        u8::RAW_BYTE_LEN + u8::RAW_BYTE_LEN + u8::RAW_BYTE_LEN + u8::RAW_BYTE_LEN;
}

#[cfg(feature = "traversal")]
impl<'a> SomeRecord<'a> for ColorRecord {
    fn traverse(self, data: FontData<'a>) -> RecordResolver<'a> {
        RecordResolver {
            name: "ColorRecord",
            get_field: Box::new(move |idx, _data| match idx {
                0usize => Some(Field::new("blue", self.blue())),
                1usize => Some(Field::new("green", self.green())),
                2usize => Some(Field::new("red", self.red())),
                3usize => Some(Field::new("alpha", self.alpha())),
                _ => None,
            }),
            data,
        }
    }
}

/// [CPAL (Palette Type Array)](https://learn.microsoft.com/en-us/typography/opentype/spec/cpal#palette-type-array) record
#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct PaletteTypeArrayMarker {
    palette_types_byte_len: usize,
}

impl PaletteTypeArrayMarker {
    fn palette_types_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + self.palette_types_byte_len
    }
}

impl ReadArgs for PaletteTypeArray<'_> {
    type Args = u16;
}

impl<'a> FontReadWithArgs<'a> for PaletteTypeArray<'a> {
    fn read_with_args(data: FontData<'a>, args: &u16) -> Result<Self, ReadError> {
        let num_palettes = *args;
        let mut cursor = data.cursor();
        let palette_types_byte_len = num_palettes as usize * u32::RAW_BYTE_LEN;
        cursor.advance_by(palette_types_byte_len);
        cursor.finish(PaletteTypeArrayMarker {
            palette_types_byte_len,
        })
    }
}

/// [CPAL (Palette Type Array)](https://learn.microsoft.com/en-us/typography/opentype/spec/cpal#palette-type-array) record
pub type PaletteTypeArray<'a> = TableRef<'a, PaletteTypeArrayMarker>;

impl<'a> PaletteTypeArray<'a> {
    /// Array of 32-bit flag fields that describe properties of each
    /// palette. See below for details.
    pub fn palette_types(&self) -> &'a [BigEndian<u32>] {
        let range = self.shape.palette_types_byte_range();
        self.data.read_array(range).unwrap()
    }
}

#[cfg(feature = "traversal")]
impl<'a> SomeTable<'a> for PaletteTypeArray<'a> {
    fn type_name(&self) -> &str {
        "PaletteTypeArray"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new("palette_types", self.palette_types())),
            _ => None,
        }
    }
}

#[cfg(feature = "traversal")]
impl<'a> std::fmt::Debug for PaletteTypeArray<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

/// [CPAL (Palette Label Array)](https://learn.microsoft.com/en-us/typography/opentype/spec/cpal#palette-labels-array) record
#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct PaletteLabelArrayMarker {
    palette_labels_byte_len: usize,
}

impl PaletteLabelArrayMarker {
    fn palette_labels_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + self.palette_labels_byte_len
    }
}

impl ReadArgs for PaletteLabelArray<'_> {
    type Args = u16;
}

impl<'a> FontReadWithArgs<'a> for PaletteLabelArray<'a> {
    fn read_with_args(data: FontData<'a>, args: &u16) -> Result<Self, ReadError> {
        let num_palettes = *args;
        let mut cursor = data.cursor();
        let palette_labels_byte_len = num_palettes as usize * u16::RAW_BYTE_LEN;
        cursor.advance_by(palette_labels_byte_len);
        cursor.finish(PaletteLabelArrayMarker {
            palette_labels_byte_len,
        })
    }
}

/// [CPAL (Palette Label Array)](https://learn.microsoft.com/en-us/typography/opentype/spec/cpal#palette-labels-array) record
pub type PaletteLabelArray<'a> = TableRef<'a, PaletteLabelArrayMarker>;

impl<'a> PaletteLabelArray<'a> {
    /// Array of 'name' table IDs (typically in the font-specific name
    /// ID range) that specify user interface strings associated with
    /// each palette. Use 0xFFFF if no name ID is provided for a
    /// palette.
    pub fn palette_labels(&self) -> &'a [BigEndian<u16>] {
        let range = self.shape.palette_labels_byte_range();
        self.data.read_array(range).unwrap()
    }
}

#[cfg(feature = "traversal")]
impl<'a> SomeTable<'a> for PaletteLabelArray<'a> {
    fn type_name(&self) -> &str {
        "PaletteLabelArray"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new("palette_labels", self.palette_labels())),
            _ => None,
        }
    }
}

#[cfg(feature = "traversal")]
impl<'a> std::fmt::Debug for PaletteLabelArray<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

/// [CPAL (Palette Label Entry Array)](https://learn.microsoft.com/en-us/typography/opentype/spec/cpal#palette-entry-label-array) record
#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct PaletteLabelEntryArrayMarker {
    palette_entry_labels_byte_len: usize,
}

impl PaletteLabelEntryArrayMarker {
    fn palette_entry_labels_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + self.palette_entry_labels_byte_len
    }
}

impl ReadArgs for PaletteLabelEntryArray<'_> {
    type Args = u16;
}

impl<'a> FontReadWithArgs<'a> for PaletteLabelEntryArray<'a> {
    fn read_with_args(data: FontData<'a>, args: &u16) -> Result<Self, ReadError> {
        let num_palette_entries = *args;
        let mut cursor = data.cursor();
        let palette_entry_labels_byte_len = num_palette_entries as usize * u16::RAW_BYTE_LEN;
        cursor.advance_by(palette_entry_labels_byte_len);
        cursor.finish(PaletteLabelEntryArrayMarker {
            palette_entry_labels_byte_len,
        })
    }
}

/// [CPAL (Palette Label Entry Array)](https://learn.microsoft.com/en-us/typography/opentype/spec/cpal#palette-entry-label-array) record
pub type PaletteLabelEntryArray<'a> = TableRef<'a, PaletteLabelEntryArrayMarker>;

impl<'a> PaletteLabelEntryArray<'a> {
    /// Array of 'name' table IDs (typically in the font-specific name
    /// ID range) that specify user interface strings associated with
    /// each palette entry, e.g. “Outline”, “Fill”. This set of
    /// palette entry labels applies to all palettes in the font. Use
    /// 0xFFFF if no name ID is provided for a palette entry.
    pub fn palette_entry_labels(&self) -> &'a [BigEndian<u16>] {
        let range = self.shape.palette_entry_labels_byte_range();
        self.data.read_array(range).unwrap()
    }
}

#[cfg(feature = "traversal")]
impl<'a> SomeTable<'a> for PaletteLabelEntryArray<'a> {
    fn type_name(&self) -> &str {
        "PaletteLabelEntryArray"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new(
                "palette_entry_labels",
                self.palette_entry_labels(),
            )),
            _ => None,
        }
    }
}

#[cfg(feature = "traversal")]
impl<'a> std::fmt::Debug for PaletteLabelEntryArray<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}
