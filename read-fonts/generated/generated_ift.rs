// THIS FILE IS AUTOGENERATED.
// Any changes to this file will be overwritten.
// For more information about how codegen works, see font-codegen/README.md

#[allow(unused_imports)]
use crate::codegen_prelude::*;

#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct IFTMarker {}

impl IFTMarker {}

impl TopLevelTable for IFT<'_> {
    /// `IFT `
    const TAG: Tag = Tag::new(b"IFT ");
}

impl<'a> FontRead<'a> for IFT<'a> {
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        let cursor = data.cursor();
        cursor.finish(IFTMarker {})
    }
}

pub type IFT<'a> = TableRef<'a, IFTMarker>;

impl<'a> IFT<'a> {}

#[cfg(feature = "traversal")]
impl<'a> SomeTable<'a> for IFT<'a> {
    fn type_name(&self) -> &str {
        "IFT"
    }

    #[allow(unused_variables)]
    #[allow(clippy::match_single_binding)]
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            _ => None,
        }
    }
}

#[cfg(feature = "traversal")]
impl<'a> std::fmt::Debug for IFT<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct IFTXMarker {}

impl IFTXMarker {}

impl TopLevelTable for IFTX<'_> {
    /// `IFTX`
    const TAG: Tag = Tag::new(b"IFTX");
}

impl<'a> FontRead<'a> for IFTX<'a> {
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        let cursor = data.cursor();
        cursor.finish(IFTXMarker {})
    }
}

pub type IFTX<'a> = TableRef<'a, IFTXMarker>;

impl<'a> IFTX<'a> {}

#[cfg(feature = "traversal")]
impl<'a> SomeTable<'a> for IFTX<'a> {
    fn type_name(&self) -> &str {
        "IFTX"
    }

    #[allow(unused_variables)]
    #[allow(clippy::match_single_binding)]
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            _ => None,
        }
    }
}

#[cfg(feature = "traversal")]
impl<'a> std::fmt::Debug for IFTX<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

#[derive(Clone)]
pub enum Ift<'a> {
    Format1(PatchMapFormat1<'a>),
    Format2(PatchMapFormat2<'a>),
}

impl<'a> Ift<'a> {
    ///Return the `FontData` used to resolve offsets for this table.
    pub fn offset_data(&self) -> FontData<'a> {
        match self {
            Self::Format1(item) => item.offset_data(),
            Self::Format2(item) => item.offset_data(),
        }
    }

    /// Format identifier: format = 1
    pub fn format(&self) -> u8 {
        match self {
            Self::Format1(item) => item.format(),
            Self::Format2(item) => item.format(),
        }
    }
}

impl<'a> FontRead<'a> for Ift<'a> {
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        let format: u8 = data.read_at(0usize)?;
        match format {
            PatchMapFormat1Marker::FORMAT => Ok(Self::Format1(FontRead::read(data)?)),
            PatchMapFormat2Marker::FORMAT => Ok(Self::Format2(FontRead::read(data)?)),
            other => Err(ReadError::InvalidFormat(other.into())),
        }
    }
}

#[cfg(feature = "traversal")]
impl<'a> Ift<'a> {
    fn dyn_inner<'b>(&'b self) -> &'b dyn SomeTable<'a> {
        match self {
            Self::Format1(table) => table,
            Self::Format2(table) => table,
        }
    }
}

#[cfg(feature = "traversal")]
impl<'a> std::fmt::Debug for Ift<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        self.dyn_inner().fmt(f)
    }
}

#[cfg(feature = "traversal")]
impl<'a> SomeTable<'a> for Ift<'a> {
    fn type_name(&self) -> &str {
        self.dyn_inner().type_name()
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        self.dyn_inner().get_field(idx)
    }
}

impl Format<u8> for PatchMapFormat1Marker {
    const FORMAT: u8 = 1;
}

/// [Patch Map Format Format 1](https://w3c.github.io/IFT/Overview.html#patch-map-format-1)
#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct PatchMapFormat1Marker {
    compatibility_id_byte_len: usize,
    applied_entries_bitmap_byte_len: usize,
    uri_template_byte_len: usize,
}

impl PatchMapFormat1Marker {
    fn format_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + u8::RAW_BYTE_LEN
    }
    fn _reserved_byte_range(&self) -> Range<usize> {
        let start = self.format_byte_range().end;
        start..start + u32::RAW_BYTE_LEN
    }
    fn compatibility_id_byte_range(&self) -> Range<usize> {
        let start = self._reserved_byte_range().end;
        start..start + self.compatibility_id_byte_len
    }
    fn max_entry_index_byte_range(&self) -> Range<usize> {
        let start = self.compatibility_id_byte_range().end;
        start..start + u16::RAW_BYTE_LEN
    }
    fn glyph_count_byte_range(&self) -> Range<usize> {
        let start = self.max_entry_index_byte_range().end;
        start..start + u32::RAW_BYTE_LEN
    }
    fn glyph_map_offset_byte_range(&self) -> Range<usize> {
        let start = self.glyph_count_byte_range().end;
        start..start + Offset32::RAW_BYTE_LEN
    }
    fn feature_map_offset_byte_range(&self) -> Range<usize> {
        let start = self.glyph_map_offset_byte_range().end;
        start..start + Offset32::RAW_BYTE_LEN
    }
    fn applied_entries_bitmap_byte_range(&self) -> Range<usize> {
        let start = self.feature_map_offset_byte_range().end;
        start..start + self.applied_entries_bitmap_byte_len
    }
    fn uri_template_length_byte_range(&self) -> Range<usize> {
        let start = self.applied_entries_bitmap_byte_range().end;
        start..start + u16::RAW_BYTE_LEN
    }
    fn uri_template_byte_range(&self) -> Range<usize> {
        let start = self.uri_template_length_byte_range().end;
        start..start + self.uri_template_byte_len
    }
    fn patch_encoding_byte_range(&self) -> Range<usize> {
        let start = self.uri_template_byte_range().end;
        start..start + u8::RAW_BYTE_LEN
    }
}

impl<'a> FontRead<'a> for PatchMapFormat1<'a> {
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        let mut cursor = data.cursor();
        cursor.advance::<u8>();
        cursor.advance::<u32>();
        let compatibility_id_byte_len = (4_usize)
            .checked_mul(u32::RAW_BYTE_LEN)
            .ok_or(ReadError::OutOfBounds)?;
        cursor.advance_by(compatibility_id_byte_len);
        let max_entry_index: u16 = cursor.read()?;
        cursor.advance::<u32>();
        cursor.advance::<Offset32>();
        cursor.advance::<Offset32>();
        let applied_entries_bitmap_byte_len = (transforms::bitmap(max_entry_index + 1))
            .checked_mul(u8::RAW_BYTE_LEN)
            .ok_or(ReadError::OutOfBounds)?;
        cursor.advance_by(applied_entries_bitmap_byte_len);
        let uri_template_length: u16 = cursor.read()?;
        let uri_template_byte_len = (uri_template_length as usize)
            .checked_mul(u8::RAW_BYTE_LEN)
            .ok_or(ReadError::OutOfBounds)?;
        cursor.advance_by(uri_template_byte_len);
        cursor.advance::<u8>();
        cursor.finish(PatchMapFormat1Marker {
            compatibility_id_byte_len,
            applied_entries_bitmap_byte_len,
            uri_template_byte_len,
        })
    }
}

/// [Patch Map Format Format 1](https://w3c.github.io/IFT/Overview.html#patch-map-format-1)
pub type PatchMapFormat1<'a> = TableRef<'a, PatchMapFormat1Marker>;

impl<'a> PatchMapFormat1<'a> {
    /// Format identifier: format = 1
    pub fn format(&self) -> u8 {
        let range = self.shape.format_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Unique ID that identifies compatible patches.
    pub fn compatibility_id(&self) -> &'a [BigEndian<u32>] {
        let range = self.shape.compatibility_id_byte_range();
        self.data.read_array(range).unwrap()
    }

    /// Number of entries and glyphs that are mapped.
    pub fn max_entry_index(&self) -> u16 {
        let range = self.shape.max_entry_index_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    pub fn glyph_count(&self) -> u32 {
        let range = self.shape.glyph_count_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Sub table that maps glyph ids to entry indices.
    pub fn glyph_map_offset(&self) -> Offset32 {
        let range = self.shape.glyph_map_offset_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Attempt to resolve [`glyph_map_offset`][Self::glyph_map_offset].
    pub fn glyph_map(&self) -> Result<GlyphMap<'a>, ReadError> {
        let data = self.data;
        let args = self.glyph_count();
        self.glyph_map_offset().resolve_with_args(data, &args)
    }

    /// Sub table that maps feature and glyph ids to entry indices.
    pub fn feature_map_offset(&self) -> Nullable<Offset32> {
        let range = self.shape.feature_map_offset_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Attempt to resolve [`feature_map_offset`][Self::feature_map_offset].
    pub fn feature_map(&self) -> Option<Result<FeatureMap<'a>, ReadError>> {
        let data = self.data;
        self.feature_map_offset().resolve(data)
    }

    pub fn applied_entries_bitmap(&self) -> &'a [u8] {
        let range = self.shape.applied_entries_bitmap_byte_range();
        self.data.read_array(range).unwrap()
    }

    pub fn uri_template_length(&self) -> u16 {
        let range = self.shape.uri_template_length_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    pub fn uri_template(&self) -> &'a [u8] {
        let range = self.shape.uri_template_byte_range();
        self.data.read_array(range).unwrap()
    }

    /// Patch format number for patches referenced by this mapping.
    pub fn patch_encoding(&self) -> u8 {
        let range = self.shape.patch_encoding_byte_range();
        self.data.read_at(range.start).unwrap()
    }
}

#[cfg(feature = "traversal")]
impl<'a> SomeTable<'a> for PatchMapFormat1<'a> {
    fn type_name(&self) -> &str {
        "PatchMapFormat1"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new("format", self.format())),
            1usize => Some(Field::new("compatibility_id", self.compatibility_id())),
            2usize => Some(Field::new("max_entry_index", self.max_entry_index())),
            3usize => Some(Field::new("glyph_count", self.glyph_count())),
            4usize => Some(Field::new(
                "glyph_map_offset",
                FieldType::offset(self.glyph_map_offset(), self.glyph_map()),
            )),
            5usize => Some(Field::new(
                "feature_map_offset",
                FieldType::offset(self.feature_map_offset(), self.feature_map()),
            )),
            6usize => Some(Field::new(
                "applied_entries_bitmap",
                self.applied_entries_bitmap(),
            )),
            7usize => Some(Field::new(
                "uri_template_length",
                self.uri_template_length(),
            )),
            8usize => Some(Field::new("uri_template", self.uri_template())),
            9usize => Some(Field::new("patch_encoding", self.patch_encoding())),
            _ => None,
        }
    }
}

#[cfg(feature = "traversal")]
impl<'a> std::fmt::Debug for PatchMapFormat1<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct GlyphMapMarker {
    entry_index_byte_len: usize,
}

impl GlyphMapMarker {
    fn first_mapped_glyph_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + u16::RAW_BYTE_LEN
    }
    fn entry_index_byte_range(&self) -> Range<usize> {
        let start = self.first_mapped_glyph_byte_range().end;
        start..start + self.entry_index_byte_len
    }
}

impl ReadArgs for GlyphMap<'_> {
    type Args = u32;
}

impl<'a> FontReadWithArgs<'a> for GlyphMap<'a> {
    fn read_with_args(data: FontData<'a>, args: &u32) -> Result<Self, ReadError> {
        let glyph_count = *args;
        let mut cursor = data.cursor();
        let first_mapped_glyph: u16 = cursor.read()?;
        let entry_index_byte_len = (transforms::subtract(glyph_count, first_mapped_glyph))
            .checked_mul(u8::RAW_BYTE_LEN)
            .ok_or(ReadError::OutOfBounds)?;
        cursor.advance_by(entry_index_byte_len);
        cursor.finish(GlyphMapMarker {
            entry_index_byte_len,
        })
    }
}

impl<'a> GlyphMap<'a> {
    /// A constructor that requires additional arguments.
    ///
    /// This type requires some external state in order to be
    /// parsed.
    pub fn read(data: FontData<'a>, glyph_count: u32) -> Result<Self, ReadError> {
        let args = glyph_count;
        Self::read_with_args(data, &args)
    }
}

pub type GlyphMap<'a> = TableRef<'a, GlyphMapMarker>;

impl<'a> GlyphMap<'a> {
    pub fn first_mapped_glyph(&self) -> u16 {
        let range = self.shape.first_mapped_glyph_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    pub fn entry_index(&self) -> &'a [u8] {
        let range = self.shape.entry_index_byte_range();
        self.data.read_array(range).unwrap()
    }
}

#[cfg(feature = "traversal")]
impl<'a> SomeTable<'a> for GlyphMap<'a> {
    fn type_name(&self) -> &str {
        "GlyphMap"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new("first_mapped_glyph", self.first_mapped_glyph())),
            1usize => Some(Field::new("entry_index", self.entry_index())),
            _ => None,
        }
    }
}

#[cfg(feature = "traversal")]
impl<'a> std::fmt::Debug for GlyphMap<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct FeatureMapMarker {}

impl FeatureMapMarker {
    fn feature_count_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + u16::RAW_BYTE_LEN
    }
}

impl<'a> FontRead<'a> for FeatureMap<'a> {
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        let mut cursor = data.cursor();
        cursor.advance::<u16>();
        cursor.finish(FeatureMapMarker {})
    }
}

pub type FeatureMap<'a> = TableRef<'a, FeatureMapMarker>;

impl<'a> FeatureMap<'a> {
    pub fn feature_count(&self) -> u16 {
        let range = self.shape.feature_count_byte_range();
        self.data.read_at(range.start).unwrap()
    }
}

#[cfg(feature = "traversal")]
impl<'a> SomeTable<'a> for FeatureMap<'a> {
    fn type_name(&self) -> &str {
        "FeatureMap"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new("feature_count", self.feature_count())),
            _ => None,
        }
    }
}

#[cfg(feature = "traversal")]
impl<'a> std::fmt::Debug for FeatureMap<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Copy, bytemuck :: AnyBitPattern)]
#[repr(C)]
#[repr(packed)]
pub struct FeatureRecord {
    pub todo: u8,
}

impl FeatureRecord {
    pub fn todo(&self) -> u8 {
        self.todo
    }
}

impl FixedSize for FeatureRecord {
    const RAW_BYTE_LEN: usize = u8::RAW_BYTE_LEN;
}

#[cfg(feature = "traversal")]
impl<'a> SomeRecord<'a> for FeatureRecord {
    fn traverse(self, data: FontData<'a>) -> RecordResolver<'a> {
        RecordResolver {
            name: "FeatureRecord",
            get_field: Box::new(move |idx, _data| match idx {
                0usize => Some(Field::new("todo", self.todo())),
                _ => None,
            }),
            data,
        }
    }
}

#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Copy, bytemuck :: AnyBitPattern)]
#[repr(C)]
#[repr(packed)]
pub struct EntryMapRecord {
    pub todo: u8,
}

impl EntryMapRecord {
    pub fn todo(&self) -> u8 {
        self.todo
    }
}

impl FixedSize for EntryMapRecord {
    const RAW_BYTE_LEN: usize = u8::RAW_BYTE_LEN;
}

#[cfg(feature = "traversal")]
impl<'a> SomeRecord<'a> for EntryMapRecord {
    fn traverse(self, data: FontData<'a>) -> RecordResolver<'a> {
        RecordResolver {
            name: "EntryMapRecord",
            get_field: Box::new(move |idx, _data| match idx {
                0usize => Some(Field::new("todo", self.todo())),
                _ => None,
            }),
            data,
        }
    }
}

impl Format<u8> for PatchMapFormat2Marker {
    const FORMAT: u8 = 2;
}

/// [Patch Map Format Format 2](https://w3c.github.io/IFT/Overview.html#patch-map-format-1)
#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct PatchMapFormat2Marker {}

impl PatchMapFormat2Marker {
    fn format_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + u8::RAW_BYTE_LEN
    }
    fn todo_byte_range(&self) -> Range<usize> {
        let start = self.format_byte_range().end;
        start..start + u32::RAW_BYTE_LEN
    }
}

impl<'a> FontRead<'a> for PatchMapFormat2<'a> {
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        let mut cursor = data.cursor();
        cursor.advance::<u8>();
        cursor.advance::<u32>();
        cursor.finish(PatchMapFormat2Marker {})
    }
}

/// [Patch Map Format Format 2](https://w3c.github.io/IFT/Overview.html#patch-map-format-1)
pub type PatchMapFormat2<'a> = TableRef<'a, PatchMapFormat2Marker>;

impl<'a> PatchMapFormat2<'a> {
    /// Format identifier: format = 2
    pub fn format(&self) -> u8 {
        let range = self.shape.format_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    pub fn todo(&self) -> u32 {
        let range = self.shape.todo_byte_range();
        self.data.read_at(range.start).unwrap()
    }
}

#[cfg(feature = "traversal")]
impl<'a> SomeTable<'a> for PatchMapFormat2<'a> {
    fn type_name(&self) -> &str {
        "PatchMapFormat2"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new("format", self.format())),
            1usize => Some(Field::new("todo", self.todo())),
            _ => None,
        }
    }
}

#[cfg(feature = "traversal")]
impl<'a> std::fmt::Debug for PatchMapFormat2<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}
