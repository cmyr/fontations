// THIS FILE IS AUTOGENERATED.
// Any changes to this file will be overwritten.
// For more information about how codegen works, see font-codegen/README.md

#[allow(unused_imports)]
use crate::codegen_prelude::*;

#[derive(Clone)]
pub enum Ift<'a> {
    Format1(PatchMapFormat1<'a>),
    Format2(PatchMapFormat2<'a>),
}

impl<'a> Ift<'a> {
    ///Return the `FontData` used to resolve offsets for this table.
    pub fn offset_data(&self) -> FontData<'a> {
        match self {
            Self::Format1(item) => item.offset_data(),
            Self::Format2(item) => item.offset_data(),
        }
    }

    /// Format identifier: format = 1
    pub fn format(&self) -> u8 {
        match self {
            Self::Format1(item) => item.format(),
            Self::Format2(item) => item.format(),
        }
    }
}

impl<'a> FontRead<'a> for Ift<'a> {
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        let format: u8 = data.read_at(0usize)?;
        match format {
            PatchMapFormat1Marker::FORMAT => Ok(Self::Format1(FontRead::read(data)?)),
            PatchMapFormat2Marker::FORMAT => Ok(Self::Format2(FontRead::read(data)?)),
            other => Err(ReadError::InvalidFormat(other.into())),
        }
    }
}

#[cfg(feature = "traversal")]
impl<'a> Ift<'a> {
    fn dyn_inner<'b>(&'b self) -> &'b dyn SomeTable<'a> {
        match self {
            Self::Format1(table) => table,
            Self::Format2(table) => table,
        }
    }
}

#[cfg(feature = "traversal")]
impl<'a> std::fmt::Debug for Ift<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        self.dyn_inner().fmt(f)
    }
}

#[cfg(feature = "traversal")]
impl<'a> SomeTable<'a> for Ift<'a> {
    fn type_name(&self) -> &str {
        self.dyn_inner().type_name()
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        self.dyn_inner().get_field(idx)
    }
}

impl Format<u8> for PatchMapFormat1Marker {
    const FORMAT: u8 = 1;
}

/// [Patch Map Format Format 1](https://w3c.github.io/IFT/Overview.html#patch-map-format-1)
#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct PatchMapFormat1Marker {
    compatibility_id_byte_len: usize,
    applied_entries_bitmap_byte_len: usize,
    uri_template_byte_len: usize,
}

impl PatchMapFormat1Marker {
    fn format_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + u8::RAW_BYTE_LEN
    }
    fn _reserved_byte_range(&self) -> Range<usize> {
        let start = self.format_byte_range().end;
        start..start + u32::RAW_BYTE_LEN
    }
    fn compatibility_id_byte_range(&self) -> Range<usize> {
        let start = self._reserved_byte_range().end;
        start..start + self.compatibility_id_byte_len
    }
    fn max_entry_index_byte_range(&self) -> Range<usize> {
        let start = self.compatibility_id_byte_range().end;
        start..start + u16::RAW_BYTE_LEN
    }
    fn glyph_count_byte_range(&self) -> Range<usize> {
        let start = self.max_entry_index_byte_range().end;
        start..start + u32::RAW_BYTE_LEN
    }
    fn glyph_map_offset_byte_range(&self) -> Range<usize> {
        let start = self.glyph_count_byte_range().end;
        start..start + Offset32::RAW_BYTE_LEN
    }
    fn feature_map_offset_byte_range(&self) -> Range<usize> {
        let start = self.glyph_map_offset_byte_range().end;
        start..start + Offset32::RAW_BYTE_LEN
    }
    fn applied_entries_bitmap_byte_range(&self) -> Range<usize> {
        let start = self.feature_map_offset_byte_range().end;
        start..start + self.applied_entries_bitmap_byte_len
    }
    fn uri_template_length_byte_range(&self) -> Range<usize> {
        let start = self.applied_entries_bitmap_byte_range().end;
        start..start + u16::RAW_BYTE_LEN
    }
    fn uri_template_byte_range(&self) -> Range<usize> {
        let start = self.uri_template_length_byte_range().end;
        start..start + self.uri_template_byte_len
    }
    fn patch_encoding_byte_range(&self) -> Range<usize> {
        let start = self.uri_template_byte_range().end;
        start..start + u8::RAW_BYTE_LEN
    }
}

impl<'a> FontRead<'a> for PatchMapFormat1<'a> {
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        let mut cursor = data.cursor();
        cursor.advance::<u8>();
        cursor.advance::<u32>();
        let compatibility_id_byte_len = (4_usize)
            .checked_mul(u32::RAW_BYTE_LEN)
            .ok_or(ReadError::OutOfBounds)?;
        cursor.advance_by(compatibility_id_byte_len);
        let max_entry_index: u16 = cursor.read()?;
        cursor.advance::<u32>();
        cursor.advance::<Offset32>();
        cursor.advance::<Offset32>();
        let applied_entries_bitmap_byte_len = (transforms::bitmap_len(max_entry_index + 1))
            .checked_mul(u8::RAW_BYTE_LEN)
            .ok_or(ReadError::OutOfBounds)?;
        cursor.advance_by(applied_entries_bitmap_byte_len);
        let uri_template_length: u16 = cursor.read()?;
        let uri_template_byte_len = (uri_template_length as usize)
            .checked_mul(u8::RAW_BYTE_LEN)
            .ok_or(ReadError::OutOfBounds)?;
        cursor.advance_by(uri_template_byte_len);
        cursor.advance::<u8>();
        cursor.finish(PatchMapFormat1Marker {
            compatibility_id_byte_len,
            applied_entries_bitmap_byte_len,
            uri_template_byte_len,
        })
    }
}

/// [Patch Map Format Format 1](https://w3c.github.io/IFT/Overview.html#patch-map-format-1)
pub type PatchMapFormat1<'a> = TableRef<'a, PatchMapFormat1Marker>;

impl<'a> PatchMapFormat1<'a> {
    /// Format identifier: format = 1
    pub fn format(&self) -> u8 {
        let range = self.shape.format_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Unique ID that identifies compatible patches.
    pub fn compatibility_id(&self) -> &'a [BigEndian<u32>] {
        let range = self.shape.compatibility_id_byte_range();
        self.data.read_array(range).unwrap()
    }

    /// Number of entries and glyphs that are mapped.
    pub fn max_entry_index(&self) -> u16 {
        let range = self.shape.max_entry_index_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    pub fn glyph_count(&self) -> u32 {
        let range = self.shape.glyph_count_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Sub table that maps glyph ids to entry indices.
    pub fn glyph_map_offset(&self) -> Offset32 {
        let range = self.shape.glyph_map_offset_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Attempt to resolve [`glyph_map_offset`][Self::glyph_map_offset].
    pub fn glyph_map(&self) -> Result<GlyphMap<'a>, ReadError> {
        let data = self.data;
        let args = (self.glyph_count(), self.max_entry_index());
        self.glyph_map_offset().resolve_with_args(data, &args)
    }

    /// Sub table that maps feature and glyph ids to entry indices.
    pub fn feature_map_offset(&self) -> Nullable<Offset32> {
        let range = self.shape.feature_map_offset_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Attempt to resolve [`feature_map_offset`][Self::feature_map_offset].
    pub fn feature_map(&self) -> Option<Result<FeatureMap<'a>, ReadError>> {
        let data = self.data;
        let args = self.max_entry_index();
        self.feature_map_offset().resolve_with_args(data, &args)
    }

    pub fn applied_entries_bitmap(&self) -> &'a [u8] {
        let range = self.shape.applied_entries_bitmap_byte_range();
        self.data.read_array(range).unwrap()
    }

    pub fn uri_template_length(&self) -> u16 {
        let range = self.shape.uri_template_length_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    pub fn uri_template(&self) -> &'a [u8] {
        let range = self.shape.uri_template_byte_range();
        self.data.read_array(range).unwrap()
    }

    /// Patch format number for patches referenced by this mapping.
    pub fn patch_encoding(&self) -> u8 {
        let range = self.shape.patch_encoding_byte_range();
        self.data.read_at(range.start).unwrap()
    }
}

#[cfg(feature = "traversal")]
impl<'a> SomeTable<'a> for PatchMapFormat1<'a> {
    fn type_name(&self) -> &str {
        "PatchMapFormat1"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new("format", self.format())),
            1usize => Some(Field::new("compatibility_id", self.compatibility_id())),
            2usize => Some(Field::new("max_entry_index", self.max_entry_index())),
            3usize => Some(Field::new("glyph_count", self.glyph_count())),
            4usize => Some(Field::new(
                "glyph_map_offset",
                FieldType::offset(self.glyph_map_offset(), self.glyph_map()),
            )),
            5usize => Some(Field::new(
                "feature_map_offset",
                FieldType::offset(self.feature_map_offset(), self.feature_map()),
            )),
            6usize => Some(Field::new(
                "applied_entries_bitmap",
                self.applied_entries_bitmap(),
            )),
            7usize => Some(Field::new(
                "uri_template_length",
                self.uri_template_length(),
            )),
            8usize => Some(Field::new("uri_template", self.uri_template())),
            9usize => Some(Field::new("patch_encoding", self.patch_encoding())),
            _ => None,
        }
    }
}

#[cfg(feature = "traversal")]
impl<'a> std::fmt::Debug for PatchMapFormat1<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct GlyphMapMarker {
    max_entry_index: u16,
    entry_index_byte_len: usize,
}

impl GlyphMapMarker {
    fn first_mapped_glyph_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + u16::RAW_BYTE_LEN
    }
    fn entry_index_byte_range(&self) -> Range<usize> {
        let start = self.first_mapped_glyph_byte_range().end;
        start..start + self.entry_index_byte_len
    }
}

impl ReadArgs for GlyphMap<'_> {
    type Args = (u32, u16);
}

impl<'a> FontReadWithArgs<'a> for GlyphMap<'a> {
    fn read_with_args(data: FontData<'a>, args: &(u32, u16)) -> Result<Self, ReadError> {
        let (glyph_count, max_entry_index) = *args;
        let mut cursor = data.cursor();
        let first_mapped_glyph: u16 = cursor.read()?;
        let entry_index_byte_len = (transforms::subtract(glyph_count, first_mapped_glyph))
            .checked_mul(<U8Or16 as ComputeSize>::compute_size(&max_entry_index)?)
            .ok_or(ReadError::OutOfBounds)?;
        cursor.advance_by(entry_index_byte_len);
        cursor.finish(GlyphMapMarker {
            max_entry_index,
            entry_index_byte_len,
        })
    }
}

impl<'a> GlyphMap<'a> {
    /// A constructor that requires additional arguments.
    ///
    /// This type requires some external state in order to be
    /// parsed.
    pub fn read(
        data: FontData<'a>,
        glyph_count: u32,
        max_entry_index: u16,
    ) -> Result<Self, ReadError> {
        let args = (glyph_count, max_entry_index);
        Self::read_with_args(data, &args)
    }
}

pub type GlyphMap<'a> = TableRef<'a, GlyphMapMarker>;

impl<'a> GlyphMap<'a> {
    pub fn first_mapped_glyph(&self) -> u16 {
        let range = self.shape.first_mapped_glyph_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    pub fn entry_index(&self) -> ComputedArray<'a, U8Or16> {
        let range = self.shape.entry_index_byte_range();
        self.data
            .read_with_args(range, &self.max_entry_index())
            .unwrap()
    }

    pub(crate) fn max_entry_index(&self) -> u16 {
        self.shape.max_entry_index
    }
}

#[cfg(feature = "traversal")]
impl<'a> SomeTable<'a> for GlyphMap<'a> {
    fn type_name(&self) -> &str {
        "GlyphMap"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new("first_mapped_glyph", self.first_mapped_glyph())),
            1usize => Some(Field::new("entry_index", traversal::FieldType::Unknown)),
            _ => None,
        }
    }
}

#[cfg(feature = "traversal")]
impl<'a> std::fmt::Debug for GlyphMap<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct FeatureMapMarker {
    max_entry_index: u16,
    feature_records_byte_len: usize,
    entry_map_data_byte_len: usize,
}

impl FeatureMapMarker {
    fn feature_count_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + u16::RAW_BYTE_LEN
    }
    fn feature_records_byte_range(&self) -> Range<usize> {
        let start = self.feature_count_byte_range().end;
        start..start + self.feature_records_byte_len
    }
    fn entry_map_data_byte_range(&self) -> Range<usize> {
        let start = self.feature_records_byte_range().end;
        start..start + self.entry_map_data_byte_len
    }
}

impl ReadArgs for FeatureMap<'_> {
    type Args = u16;
}

impl<'a> FontReadWithArgs<'a> for FeatureMap<'a> {
    fn read_with_args(data: FontData<'a>, args: &u16) -> Result<Self, ReadError> {
        let max_entry_index = *args;
        let mut cursor = data.cursor();
        let feature_count: u16 = cursor.read()?;
        let feature_records_byte_len = (feature_count as usize)
            .checked_mul(<FeatureRecord as ComputeSize>::compute_size(
                &max_entry_index,
            )?)
            .ok_or(ReadError::OutOfBounds)?;
        cursor.advance_by(feature_records_byte_len);
        let entry_map_data_byte_len =
            cursor.remaining_bytes() / u8::RAW_BYTE_LEN * u8::RAW_BYTE_LEN;
        cursor.advance_by(entry_map_data_byte_len);
        cursor.finish(FeatureMapMarker {
            max_entry_index,
            feature_records_byte_len,
            entry_map_data_byte_len,
        })
    }
}

impl<'a> FeatureMap<'a> {
    /// A constructor that requires additional arguments.
    ///
    /// This type requires some external state in order to be
    /// parsed.
    pub fn read(data: FontData<'a>, max_entry_index: u16) -> Result<Self, ReadError> {
        let args = max_entry_index;
        Self::read_with_args(data, &args)
    }
}

pub type FeatureMap<'a> = TableRef<'a, FeatureMapMarker>;

impl<'a> FeatureMap<'a> {
    pub fn feature_count(&self) -> u16 {
        let range = self.shape.feature_count_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    pub fn feature_records(&self) -> ComputedArray<'a, FeatureRecord> {
        let range = self.shape.feature_records_byte_range();
        self.data
            .read_with_args(range, &self.max_entry_index())
            .unwrap()
    }

    pub fn entry_map_data(&self) -> &'a [u8] {
        let range = self.shape.entry_map_data_byte_range();
        self.data.read_array(range).unwrap()
    }

    pub(crate) fn max_entry_index(&self) -> u16 {
        self.shape.max_entry_index
    }
}

#[cfg(feature = "traversal")]
impl<'a> SomeTable<'a> for FeatureMap<'a> {
    fn type_name(&self) -> &str {
        "FeatureMap"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new("feature_count", self.feature_count())),
            1usize => Some(Field::new("feature_records", traversal::FieldType::Unknown)),
            2usize => Some(Field::new("entry_map_data", self.entry_map_data())),
            _ => None,
        }
    }
}

#[cfg(feature = "traversal")]
impl<'a> std::fmt::Debug for FeatureMap<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct FeatureRecord {
    pub feature_tag: BigEndian<Tag>,
    pub first_new_entry_index: U8Or16,
    pub entry_map_count: U8Or16,
}

impl FeatureRecord {
    pub fn feature_tag(&self) -> Tag {
        self.feature_tag.get()
    }

    pub fn first_new_entry_index(&self) -> &U8Or16 {
        &self.first_new_entry_index
    }

    pub fn entry_map_count(&self) -> &U8Or16 {
        &self.entry_map_count
    }
}

impl ReadArgs for FeatureRecord {
    type Args = u16;
}

impl ComputeSize for FeatureRecord {
    #[allow(clippy::needless_question_mark)]
    fn compute_size(args: &u16) -> Result<usize, ReadError> {
        let max_entry_index = *args;
        let mut result = 0usize;
        result = result
            .checked_add(Tag::RAW_BYTE_LEN)
            .ok_or(ReadError::OutOfBounds)?;
        result = result
            .checked_add(<U8Or16 as ComputeSize>::compute_size(&max_entry_index)?)
            .ok_or(ReadError::OutOfBounds)?;
        result = result
            .checked_add(<U8Or16 as ComputeSize>::compute_size(&max_entry_index)?)
            .ok_or(ReadError::OutOfBounds)?;
        Ok(result)
    }
}

impl<'a> FontReadWithArgs<'a> for FeatureRecord {
    fn read_with_args(data: FontData<'a>, args: &u16) -> Result<Self, ReadError> {
        let mut cursor = data.cursor();
        let max_entry_index = *args;
        Ok(Self {
            feature_tag: cursor.read_be()?,
            first_new_entry_index: cursor.read_with_args(&max_entry_index)?,
            entry_map_count: cursor.read_with_args(&max_entry_index)?,
        })
    }
}

impl<'a> FeatureRecord {
    /// A constructor that requires additional arguments.
    ///
    /// This type requires some external state in order to be
    /// parsed.
    pub fn read(data: FontData<'a>, max_entry_index: u16) -> Result<Self, ReadError> {
        let args = max_entry_index;
        Self::read_with_args(data, &args)
    }
}

#[cfg(feature = "traversal")]
impl<'a> SomeRecord<'a> for FeatureRecord {
    fn traverse(self, data: FontData<'a>) -> RecordResolver<'a> {
        RecordResolver {
            name: "FeatureRecord",
            get_field: Box::new(move |idx, _data| match idx {
                0usize => Some(Field::new("feature_tag", self.feature_tag())),
                1usize => Some(Field::new(
                    "first_new_entry_index",
                    traversal::FieldType::Unknown,
                )),
                2usize => Some(Field::new("entry_map_count", traversal::FieldType::Unknown)),
                _ => None,
            }),
            data,
        }
    }
}

#[derive(Clone, Debug)]
pub struct EntryMapRecord {
    pub first_entry_index: U8Or16,
    pub last_entry_index: U8Or16,
}

impl EntryMapRecord {
    pub fn first_entry_index(&self) -> &U8Or16 {
        &self.first_entry_index
    }

    pub fn last_entry_index(&self) -> &U8Or16 {
        &self.last_entry_index
    }
}

impl ReadArgs for EntryMapRecord {
    type Args = u16;
}

impl ComputeSize for EntryMapRecord {
    #[allow(clippy::needless_question_mark)]
    fn compute_size(args: &u16) -> Result<usize, ReadError> {
        let max_entry_index = *args;
        let mut result = 0usize;
        result = result
            .checked_add(<U8Or16 as ComputeSize>::compute_size(&max_entry_index)?)
            .ok_or(ReadError::OutOfBounds)?;
        result = result
            .checked_add(<U8Or16 as ComputeSize>::compute_size(&max_entry_index)?)
            .ok_or(ReadError::OutOfBounds)?;
        Ok(result)
    }
}

impl<'a> FontReadWithArgs<'a> for EntryMapRecord {
    fn read_with_args(data: FontData<'a>, args: &u16) -> Result<Self, ReadError> {
        let mut cursor = data.cursor();
        let max_entry_index = *args;
        Ok(Self {
            first_entry_index: cursor.read_with_args(&max_entry_index)?,
            last_entry_index: cursor.read_with_args(&max_entry_index)?,
        })
    }
}

impl<'a> EntryMapRecord {
    /// A constructor that requires additional arguments.
    ///
    /// This type requires some external state in order to be
    /// parsed.
    pub fn read(data: FontData<'a>, max_entry_index: u16) -> Result<Self, ReadError> {
        let args = max_entry_index;
        Self::read_with_args(data, &args)
    }
}

#[cfg(feature = "traversal")]
impl<'a> SomeRecord<'a> for EntryMapRecord {
    fn traverse(self, data: FontData<'a>) -> RecordResolver<'a> {
        RecordResolver {
            name: "EntryMapRecord",
            get_field: Box::new(move |idx, _data| match idx {
                0usize => Some(Field::new(
                    "first_entry_index",
                    traversal::FieldType::Unknown,
                )),
                1usize => Some(Field::new(
                    "last_entry_index",
                    traversal::FieldType::Unknown,
                )),
                _ => None,
            }),
            data,
        }
    }
}

impl Format<u8> for PatchMapFormat2Marker {
    const FORMAT: u8 = 2;
}

/// [Patch Map Format Format 2](https://w3c.github.io/IFT/Overview.html#patch-map-format-1)
#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct PatchMapFormat2Marker {}

impl PatchMapFormat2Marker {
    fn format_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + u8::RAW_BYTE_LEN
    }
    fn todo_byte_range(&self) -> Range<usize> {
        let start = self.format_byte_range().end;
        start..start + u32::RAW_BYTE_LEN
    }
}

impl<'a> FontRead<'a> for PatchMapFormat2<'a> {
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        let mut cursor = data.cursor();
        cursor.advance::<u8>();
        cursor.advance::<u32>();
        cursor.finish(PatchMapFormat2Marker {})
    }
}

/// [Patch Map Format Format 2](https://w3c.github.io/IFT/Overview.html#patch-map-format-1)
pub type PatchMapFormat2<'a> = TableRef<'a, PatchMapFormat2Marker>;

impl<'a> PatchMapFormat2<'a> {
    /// Format identifier: format = 2
    pub fn format(&self) -> u8 {
        let range = self.shape.format_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    pub fn todo(&self) -> u32 {
        let range = self.shape.todo_byte_range();
        self.data.read_at(range.start).unwrap()
    }
}

#[cfg(feature = "traversal")]
impl<'a> SomeTable<'a> for PatchMapFormat2<'a> {
    fn type_name(&self) -> &str {
        "PatchMapFormat2"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new("format", self.format())),
            1usize => Some(Field::new("todo", self.todo())),
            _ => None,
        }
    }
}

#[cfg(feature = "traversal")]
impl<'a> std::fmt::Debug for PatchMapFormat2<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}
